<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Betongytor ‚Äî Material- & Kostnadsestimator PRO</title>
  <style>
    /* ================== THEME ================== */
    :root{
      --bg:#f4f9ff;
      --fg:#0f172a;
      --muted:#475569;
      --panel:#ffffff;
      --line:#dbe5f0;
      --accent:#2563eb;
      --accent-2:#10b981;
      --danger:#ef4444;
      --shadow:0 10px 24px rgba(2,32,71,.08);
      --rowBg:#ffffff;
      --rowAlt:#f8fbff;
      --rowProd:#f0fbf5;
      --rowProj:#f4f8ff;
      --tooltipBg:#111827;
      --tooltipFg:#f9fafb;
      --grad:linear-gradient(180deg,#f8fbff 0%,#eef6ff 50%,#f7fffb 100%);
    }
    body.dark-mode{
      --bg:#0b0f1a;
      --fg:#e5efff;
      --muted:#9fb0c8;
      --panel:#0f172a;
      --line:#213047;
      --accent:#60a5fa;
      --accent-2:#34d399;
      --danger:#f87171;
      --shadow:0 10px 24px rgba(0,0,0,.45);
      --rowBg:#0b1427;
      --rowAlt:#0c1a33;
      --rowProd:#0b1e19;
      --rowProj:#0b1424;
      --tooltipBg:#0b1220;
      --tooltipFg:#e5efff;
      --grad:linear-gradient(180deg,#0b0f1a 0%,#0b1220 100%);
    }
    html,body{height:100%}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif;
      background:var(--grad); color:var(--fg); margin:0;
      padding-bottom:90px;
    }

    /* ================== TOP BARS ================== */
    .toolbar{
      position:sticky;top:0;z-index:30;
      background:linear-gradient(180deg,var(--panel) 0%,rgba(255,255,255,.65) 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
      padding:10px 12px; display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      border-bottom:1px solid var(--line); box-shadow:0 6px 14px rgba(15,23,42,.06);
    }
    body.dark-mode .toolbar{
      background:linear-gradient(180deg,#0f172a 0%,#0b1220 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
      box-shadow:0 6px 14px rgba(0,0,0,.45);
    }
    .subbar{
      position:sticky;top:60px;z-index:29;
      background:linear-gradient(180deg,var(--panel) 0%,rgba(255,255,255,.9) 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
      padding:8px 12px; border-bottom:1px solid var(--line);
      display:flex; align-items:center;
    }
    body.dark-mode .subbar{
      background:linear-gradient(180deg,#0f172a 0%,#0b1220 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
    }
    .subbar .left{flex:1; display:flex; gap:8px; align-items:center}
    .subbar .right{display:flex; gap:8px; align-items:center}

    .group{display:flex;align-items:center;gap:8px;background:var(--panel);border:1px solid var(--line);padding:6px 8px;border-radius:12px}
    .btn{
      appearance:none;border:0;border-radius:12px;padding:8px 12px;cursor:pointer;font-weight:700;letter-spacing:.2px;
      box-shadow:var(--shadow);transition:transform .04s ease,filter .14s ease, background .2s ease, color .2s ease;
      background:var(--panel); color:var(--fg); border:1px solid var(--line);
    }
    .btn:active{transform:translateY(1px)}
    .btn-primary{background:var(--accent-2);color:#00140c;border:1px solid transparent}
    .btn-blue{background:var(--accent);color:#ecfeff;border:1px solid transparent}
    .icon-btn{width:42px;height:42px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:20px}
    .flag-btn{font-size:18px;line-height:1;padding:6px 10px;border-radius:10px;border:1px solid var(--line);background:var(--panel);cursor:pointer}
    .flag-btn.active{outline:2px solid var(--accent);}

    .grow{flex:1}
    .toolbar label{font-weight:600}
    .toolbar input[type="number"]{width:74px}

    /* Top "Add area" dock */
    #topAddDock{padding:10px 12px; display:flex; justify-content:flex-start}
    #btnAddAreaDock{min-width:220px}

    /* ================== LAYOUT ================== */
    #areasContainer{padding:12px}
    .area{
      background:var(--panel);border:1px solid var(--line);border-radius:16px;margin:16px 6px;padding:12px 12px 10px;
      box-shadow:var(--shadow); position:relative;
    }
    .area-header{
      display:grid;
      grid-template-columns: 260px 180px 120px 200px 1fr 180px auto;
      gap:10px; align-items:center; margin-bottom:6px
    }
    .mini-caption{grid-column:1/-1; font-size:.75em; color:var(--muted); margin-top:-2px;}
    .unit-wrap{display:flex;align-items:center;gap:6px}
    .unit-wrap input{flex:1;padding:8px 10px;border:1px solid var(--line);border-radius:10px;background:var(--panel);color:var(--fg)}
    .unit-wrap .unit{font-weight:700;color:var(--muted)}
    .del-area{background:var(--panel);color:#991b1b;border:1px solid #fecaca55;border-radius:10px;padding:8px 10px;cursor:pointer; align-self:start}
    .del-area:hover{background:#ffeff157}

    /* Small illustration top-right (50% smaller) */
    .mini-illustration{border:1px solid var(--line);background:var(--panel);border-radius:12px;padding:6px;width:170px;justify-self:end}
    .mini-illustration canvas{width:100%;height:80px;border-radius:8px;background:var(--panel)}

    /* ================== TABLE ================== */
    table.area-table{width:100%;border-collapse:separate;border-spacing:0 5px;margin-bottom:4px}
    thead tr th{font-size:.72em;text-transform:uppercase;letter-spacing:.04em;color:var(--muted);padding:3px 6px}
    table.area-table th,table.area-table td{padding:3px 6px;background:var(--rowBg);border:1px solid var(--line)}
    table.area-table th:first-child,table.area-table td:first-child{border-top-left-radius:9px;border-bottom-left-radius:9px}
    table.area-table th:last-child,table.area-table td:last-child{border-top-right-radius:9px;border-bottom-right-radius:9px}
    table.area-table input,table.area-table select{
      width:100%;box-sizing:border-box;padding:3px 6px;border:1px solid var(--line);border-radius:8px;font:inherit;background:var(--panel);color:var(--fg);
      height:26px; line-height:24px
    }
    table.area-table input:disabled, table.area-table select:disabled {
      background: var(--line);
      color: var(--muted);
      cursor: not-allowed;
    }
    .th-group{background:var(--rowAlt);font-weight:800;text-align:center;border:1px solid var(--line);padding:3px 4px}
    .td-prod{background:var(--rowProd)}
    .td-proj{background:var(--rowProj)}
    .drag-handle{cursor:grab;font-size:16px;user-select:none}
    .product-row{position:relative;background:var(--rowBg)}
    .product-row.dragging{opacity:.6}

    /* overlay actions ONLY on hover */
    .row-actions-overlay{position:absolute; top:-9px; right:6px; display:none; gap:6px; z-index:3}
    .product-row:hover .row-actions-overlay{display:flex}
    .mini{font-size:.76em;padding:3px 6px;border-radius:7px;border:1px solid var(--line);background:var(--panel);cursor:pointer; height:22px}
    .mini.ghost{border-color:var(--line);color:var(--muted)}
    .mini.warn{border-color:#fde68a55;background:#fde68a19;color:#92400e}
    .mini.danger{border-color:#fecaca55;background:#fecaca22;color:#9f1239}

    /* Inline surface info under table - small text row */
    .surface-inline{display:none; margin:6px 2px 0; font-size:.92em; color:var(--muted)}
    .surface-inline.show{display:block}

    /* Footer buttons in area (stacked, same vertical line & size; smaller buttons) */
    .footer-buttons{display:flex; flex-direction:column; gap:6px; margin-top:6px; align-items:flex-start}
    .btn-slim{padding:5px 8px; border-radius:8px; width:auto}

    /* ================== SUMMARY & INFO ================== */
    #infoSummary{margin:14px;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)}
    #infoSummary header{display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--line);padding:10px 12px}
    #infoSummary .body{padding:10px 12px}
    .info-card{border:1px solid var(--line);border-radius:12px;padding:10px;margin:8px 0;background:var(--rowAlt)}
    .product-total{border:1px solid var(--line);border-radius:12px;padding:10px;margin:8px 0;background:var(--rowAlt)}
    .product-total h5{margin:0 0 4px 0}
    .product-total .dim{color:var(--muted)}

    /* ================== STICKY FOOTER TOTAL ================== */
    #footerBar{
      position:fixed; left:0; right:0; bottom:0; z-index:40;
      background:linear-gradient(180deg,var(--panel) 0%, rgba(255,255,255,0.92) 100%);
      border-top:1px solid var(--line); display:flex; align-items:center; gap:10px; padding:10px 12px;
      box-shadow:0 -8px 20px rgba(0,0,0,.07)
    }
    body.dark-mode #footerBar{
      background:linear-gradient(180deg,#0f172a 0%, #0b1220 100%);
      box-shadow:0 -8px 20px rgba(0,0,0,.45)
    }
    #footerBar strong{font-size:1.05em}
    #footerBar .sp{flex:1}
    #footerBar .btn{padding:8px 12px;border-radius:10px}

    /* ================== TOAST & HOVERTIP ================== */
    #infoToast{
      position:fixed;right:16px;bottom:86px;background:var(--tooltipBg);color:var(--tooltipFg);padding:10px 12px;border-radius:999px;
      cursor:pointer;display:none;align-items:center;gap:8px;box-shadow:var(--shadow);z-index:45
    }
    #infoToast .dot{width:8px;height:8px;border-radius:50%;background:#22c55e}
    #hoverTip{
      position:fixed; pointer-events:none; z-index:50; display:none; max-width:320px;
      background:var(--tooltipBg); color:var(--tooltipFg); padding:8px 10px; border-radius:10px; font-size:.9em; box-shadow:var(--shadow)
    }

    /* ================== LOGS ================== */
    #logPanel{position:fixed;bottom:50px;left:0;right:0;background:#0b1220;color:#e5e7eb;font-family:ui-monospace,Consolas,monospace;font-size:.9em;max-height:230px;display:flex;flex-direction:column;border-top:2px solid #1f2937;z-index:35}
    body:not(.dark-mode) #logPanel{background:#0b1220}
    #logHeader{background:#0f172a;padding:6px 8px;font-weight:800;display:flex;align-items:center;gap:8px}
    #logHeader .sp{flex:1}
    #logHeader button{background:#1f2937;color:#fff;border:none;padding:4px 8px;margin-left:5px;cursor:pointer;font-weight:bold;border-radius:8px}
    #logContent{overflow-y:auto;padding:6px}
    #logPanel.minimized{max-height:none;height:auto}
    #logPanel.minimized #logContent{display:none}
    #logPanel.maximized{max-height:65vh}

    /* ================== PRINT ================== */
    @media print{
      .toolbar,.subbar,#topAddDock,#footerBar,#logPanel,#infoToast,#hoverTip{display:none!important}
      .area{border:none;margin:0;page-break-inside:avoid}
      .del-area,.row-actions-overlay,.drag-handle{display:none!important}
    }
  </style>
</head>
<body>
  <!-- ================== MAIN TOOLBAR ================== -->
  <div class="toolbar" id="toolbar">
    <!-- Undo/Redo then Dark/Step -->
    <button id="undo" class="btn icon-btn" disabled title="√Öngra"><span aria-hidden="true">‚Ü∂</span></button>
    <button id="redo" class="btn icon-btn" disabled title="G√∂r om"><span aria-hidden="true">‚Ü∑</span></button>
    <div class="group">
      <label for="darkModeToggle" data-i18n="dark">M√∂rkt l√§ge</label><input type="checkbox" id="darkModeToggle"/>
      <label for="stepModeToggle" data-i18n="step">Steg-f√∂r-steg</label><input type="checkbox" id="stepModeToggle"/>
    </div>

    <div class="group">
      <span data-i18n="vat">Moms</span>
      <label for="vatToggle" data-i18n="include">inkludera</label><input type="checkbox" id="vatToggle"/>
      <input type="number" id="vatPercent" value="25" step="1"/>%
    </div>

    <div class="group">
      <span data-i18n="overage">Spill</span>
      <label for="overageToggle" data-i18n="apply">anv√§nd</label><input type="checkbox" id="overageToggle"/>
      <input type="number" id="overagePercent" value="10" step="1"/>%
    </div>

    <div class="group">
      <label for="exactToggle" data-i18n="exact">Exakt ber√§kning (ingen avrundning)</label>
      <input type="checkbox" id="exactToggle"/>
    </div>

    <div class="group">
      <label for="hideDecimalsToggle" data-i18n="hideDecimals">D√∂lj decimaler</label>
      <input type="checkbox" id="hideDecimalsToggle" checked/>
    </div>

    <div class="grow"></div>

    <!-- Language FAR RIGHT -->
    <div class="group">
      <strong data-i18n="language">Spr√•k</strong>
      <button id="langSV" class="flag-btn active" title="Svenska">üá∏üá™</button>
      <button id="langEN" class="flag-btn" title="English">üá¨üáß</button>
    </div>
  </div>

  <!-- ================== SUBBAR (Import left, Export right) ================== -->
  <div class="subbar" id="subbar">
    <div class="left">
      <button id="importData" class="btn" data-i18n="import">Importera</button>
      <input type="file" id="fileInput" accept=".json,.csv,.xls,.xlsx" style="display:none"/>
    </div>
    <div class="right">
      <button id="exportJSON" class="btn" data-i18n="exportJSON">Export JSON</button>
      <button id="exportCSV" class="btn" data-i18n="exportCSV">Export CSV</button>
      <button id="exportExcel" class="btn" data-i18n="exportExcel">Export Excel</button>
      <button id="shareLink" class="btn btn-blue" data-i18n="shareLink">üîó Share Link</button>
      <button id="printBtn" class="btn" data-i18n="print">Skriv ut / PDF</button>
    </div>
  </div>

  <!-- ================== ADD AREA DOCK (top; hidden after first area) ================== -->
  <div id="topAddDock">
    <button id="btnAddAreaDock" class="btn btn-primary" data-i18n="addArea">+ L√§gg till omr√•de</button>
  </div>

  <!-- ================== AREAS ================== -->
  <div id="areasContainer"></div>

  <!-- ================== SUMMARY & INFO ================== -->
  <section id="infoSummary" style="margin-top:8px">
    <header>
      <strong data-i18n="infoTitle">Info & summeringar</strong>
      <small id="lastInfoTime" style="color:var(--muted)"></small>
    </header>
    <div class="body" id="infoBody">
      <div class="info-card" id="moistureCard">
        <strong>Fukt & fuktighet</strong>
        <p style="margin:.4em 0 .2em 0; color:var(--muted)">
          H√∂g fukthalt i underlag/luft kan √∂ka √•tg√•ngen (absorptionsf√∂rluster) och f√∂rl√§nga torktider. Rekommendation:
          torr och dammfri yta, RF ‚â§ 75‚Äì80% n√§r datablad kr√§ver det, provyta vid tveksamhet. 
          <em>(Informativt ‚Äî p√•verkar inte ber√§kning automatiskt.)</em>
        </p>
      </div>
      <em data-i18n="infoEmpty">Ingen info √§nnu. L√§gg till produkter och ytor.</em>
    </div>
  </section>

  <!-- ================== GLOBAL TEMPLATES (bottom) ================== -->
  <section id="globalProducts" style="margin:14px;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)">
    <header style="display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--line);padding:10px 12px">
      <strong data-i18n="templatesTitle">Globala Produktmallar</strong>
      <div class="template-actions" style="display:flex;gap:8px">
        <button id="addTemplate" class="btn btn-primary" data-i18n="addTemplate">+ L√§gg till mall</button>
        <button id="applyAllTemplates" class="btn" data-i18n="applyAllTemplates">Anv√§nd ALLA p√• ALLA omr√•den</button>
      </div>
    </header>
    <div class="body" id="templatesBody" style="padding:10px 12px"></div>
  </section>

  <!-- ================== STICKY FOOTER TOTAL ================== -->
  <div id="footerBar">
    <strong id="footerTotalLabel">Projektets totalsumma (exkl. moms):</strong>
    <strong id="footerTotalValue">0.00</strong>
    <span class="sp"></span>
    <button class="btn" id="btnScrollSummary">Visa summering</button>
  </div>

  <!-- ================== TOAST & HOVERTIP ================== -->
  <div id="infoToast" title="Visa info"><span class="dot"></span><span data-i18n="toast">Info uppdaterad ‚Äî Visa</span></div>
  <div id="hoverTip"></div>

  <!-- ================== LOGS ================== -->
  <div id="logPanel" class="minimized">
    <div id="logHeader">LOGGAR<span class="sp"></span>
      <button id="minimizeLog">_</button><button id="maximizeLog">&#9723;</button>
    </div>
    <div id="logContent"></div>
  </div>

  <!-- ================== DATALIST FOR SUGGESTIONS ================== -->
  <datalist id="productSuggestions"></datalist>

  <script>
  (() => {
    "use strict";

    /* ================== PRELOADED PRODUCTS ================== */
    const PRELOADED_PRODUCTS = [
      {
        name: "Testproduct 1",
        color: "#ff5733",
        calcMode: "usage",
        usagePerM2: 1.5,
        packSize: 20,
        packUnit: "kg",
        price: 450,
        priceMode: "perPack",
        layers: 1
      },
      {
        name: "Testproduct 2",
        color: "#33ff57",
        calcMode: "thickness",
        thickness: 5,
        density: 1.8,
        packSize: 25,
        packUnit: "kg",
        price: 12,
        priceMode: "perKg",
        layers: 1
      },
      {
        name: "Testproduct 3",
        color: "#3357ff",
        calcMode: "coverage",
        coverSqmPerPack: 12,
        coverLayersPerPack: 1,
        packSize: 5,
        packUnit: "L",
        price: 800,
        priceMode: "perPack",
        layers: 2
      }
    ];

    /* ================== I18N ================== */
    const i18n = {
      sv: {
        addArea: "+ L√§gg till omr√•de",
        addAreaBelow: "+ L√§gg till omr√•de under",
        undoText: "√Öngra",
        redoText: "G√∂r om",
        language: "Spr√•k",
        vat: "Moms",
        include: "inkludera",
        overage: "Spill",
        apply: "anv√§nd",
        exact: "Exakt ber√§kning (ingen avrundning)",
        dark: "M√∂rkt l√§ge",
        step: "Steg-f√∂r-steg",
        import: "Importera",
        exportJSON: "Export JSON",
        exportCSV: "Export CSV",
        exportExcel: "Export Excel",
        print: "Skriv ut / PDF",
        shareLink: "üîó Dela L√§nk",
        templatesTitle: "Globala Produktmallar",
        addTemplate: "+ L√§gg till mall",
        applyAllTemplates: "Anv√§nd ALLA p√• ALLA omr√•den",
        infoTitle: "Info & summeringar",
        infoEmpty: "Ingen info √§nnu. L√§gg till produkter och ytor.",
        toast: "Info uppdaterad ‚Äî Visa",
        areaName: "Omr√•desnamn",
        surface: "Yttyp",
        factor: "Faktor",
        size: "Storlek",
        sq: "m¬≤",
        product: "Produkt",
        calc: "L√§ge",
        usage: "√Ötg√•ng (kg per m¬≤)",
        usageHint: "Vanligen kg/m¬≤ per lager enligt datablad.",
        layers: "Lager",
        thickness: "Tjocklek (mm)",
        density: "Densitet (kg/L)",
        packSize: "F√∂rp. storlek",
        unit: "Enhet",
        priceMode: "Pris-l√§ge",
        perPack: "Pris/f√∂rp",
        perKg: "Pris/kg",
        pricePack: "Pris/f√∂rp",
        priceKg: "Pris/kg",
        needed: "Behov",
        packages: "F√∂rp",
        cost: "Kostnad",
        addProduct: "+ L√§gg till produktlager",
        calcThickness: "Tjocklek",
        calcUsage: "√Ötg√•ng/m¬≤",
        calcCoverage: "T√§ckning/f√∂rp",
        coverSqm: "T√§ckning (m¬≤/f√∂rp)",
        coverLayers: "Lager per f√∂rp",
        prodInfo: "Produktdata",
        projectInfo: "Projekt/Omr√•desdata",
        deleteArea: "Ta bort omr√•de",
        cloneAll: "Klona ‚Üí Alla",
        cloneBelow: "Klona ‚Üì Nedan",
        breakdown: "‚Ñπ Breakdown",
        remove: "Ta bort",
        hoverSurface: "Yta",
        hoverProduct: "Produkt",
        tmplAdded: "Mall tillagd",
        tmplApplyAll: "Mall applicerad p√• alla omr√•den",
        errUnsupported: "Filformatet st√∂ds inte.",
        updated: "Uppdaterad ",
        color: "F√§rg",
        hideDecimals: "D√∂lj decimaler",
        linkCopied: "L√§nk kopierad till urklipp!"
      },
      en: {
        addArea: "+ Add Area",
        addAreaBelow: "+ Add Area Below",
        undoText: "Undo",
        redoText: "Redo",
        language: "Language",
        vat: "VAT",
        include: "include",
        overage: "Overage",
        apply: "apply",
        exact: "Exact calc (no rounding)",
        dark: "Dark mode",
        step: "Step-by-step",
        import: "Import",
        exportJSON: "Export JSON",
        exportCSV: "Export CSV",
        exportExcel: "Export Excel",
        print: "Print / PDF",
        shareLink: "üîó Share Link",
        templatesTitle: "Global Product Templates",
        addTemplate: "+ Add Template",
        applyAllTemplates: "Apply ALL to ALL Areas",
        infoTitle: "Info & summaries",
        infoEmpty: "No info yet. Add products and areas.",
        toast: "Info updated ‚Äî View",
        areaName: "Area name",
        surface: "Surface",
        factor: "Factor",
        size: "Size",
        sq: "m¬≤",
        product: "Product",
        calc: "Mode",
        usage: "Usage (kg per m¬≤)",
        usageHint: "Usually kg/m¬≤ per layer per data sheet.",
        layers: "Layers",
        thickness: "Thickness (mm)",
        density: "Density (kg/L)",
        packSize: "Pack size",
        unit: "Unit",
        priceMode: "Price Mode",
        perPack: "Price/pack",
        perKg: "Price/kg",
        pricePack: "Price/pack",
        priceKg: "Price/kg",
        needed: "Needed",
        packages: "Packages",
        cost: "Cost",
        addProduct: "+ Add Product Layer",
        calcThickness: "Thickness",
        calcUsage: "Usage/m¬≤",
        calcCoverage: "Coverage/pack",
        coverSqm: "Coverage (m¬≤/pack)",
        coverLayers: "Layers per pack",
        prodInfo: "Product info",
        projectInfo: "Project/Area info",
        deleteArea: "Delete Area",
        cloneAll: "Clone ‚Üí All",
        cloneBelow: "Clone ‚Üì Below",
        breakdown: "‚Ñπ Breakdown",
        remove: "Remove",
        hoverSurface: "Surface",
        hoverProduct: "Product",
        tmplAdded: "Template added",
        tmplApplyAll: "Template applied to all areas",
        errUnsupported: "Unsupported file format.",
        updated: "Updated ",
        color: "Color",
        hideDecimals: "Hide decimals",
        linkCopied: "Link copied to clipboard!"
      }
    };

    let LANG = "sv";

    function t(k) {
      return (i18n[LANG] && i18n[LANG][k]) || k;
    }

    function applyI18n() {
      document.querySelectorAll("[data-i18n]").forEach(el => {
        el.textContent = t(el.getAttribute("data-i18n"));
      });
      refreshSummaryLabels();
    }

    /* ================== STATE ================== */
    const SURFACE_INFO = {
      sv: {
        "Smooth": { title: "Sl√§t / Polerad", desc: "St√§ngda porer; t√§t, gl√§ttad yta.", hint: "+0%", prep: "Enkel reng√∂ring; dammfri", typical: "Gl√§ttad/polerad betongplatta" },
        "Light Grind": { title: "L√§tt slipad", desc: "Mikrostruktur √∂ppnas; n√•got h√∂gre absorption.", hint: "+5%", prep: "Avfettning + l√§tt slipning", typical: "Polerad med l√§tt slipning" },
        "Medium Grind": { title: "Medium slipad", desc: "Synlig sand; mikrosprickor m√∂jliga.", hint: "+10%", prep: "Slipning P80‚ÄìP120", typical: "Trafikslitet inomhusgolv" },
        "Rough": { title: "Grov / sopad", desc: "Grov profil; h√∂g absorption.", hint: "+15%", prep: "Slipning + dammsugning; laga flagor", typical: "Utv√§ndig sopad yta" },
        "Porous/Cracked": { title: "Mycket por√∂s / sprucken", desc: "Kapill√§rer och h√•ligheter; mycket h√∂g absorption med sprickor.", hint: "+25%", prep: "Sprickinjektering + primer", typical: "Gammal platta, frostskador" },
        "Custom": { title: "Anpassad", desc: "Anv√§ndardefinierad ytfaktor.", hint: "beroende", prep: "‚Äî", typical: "‚Äî" }
      },
      en: {
        "Smooth": { title: "Smooth / polished", desc: "Closed pores; dense, burnished surface.", hint: "+0%", prep: "Light cleaning; dust-free", typical: "Troweled/Polished slab" },
        "Light Grind": { title: "Lightly ground", desc: "Micro texture opens; slightly higher uptake.", hint: "+5%", prep: "Degrease + light grind", typical: "Polished with light hone" },
        "Medium Grind": { title: "Medium ground", desc: "Visible sand; micro-cracks possible.", hint: "+10%", prep: "Grinding P80‚ÄìP120", typical: "Traffic-worn interior" },
        "Rough": { title: "Rough / broomed", desc: "Coarse profile; high absorption.", hint: "+15%", prep: "Grinding + vacuum; repair spalls", typical: "Exterior broom finish" },
        "Porous/Cracked": { title: "Highly porous / cracked", desc: "Capillaries & voids; very high absorption with cracks.", hint: "+25%", prep: "Crack injection + primer", typical: "Old slab, freeze-thaw damage" },
        "Custom": { title: "Custom", desc: "User-defined surface factor.", hint: "depends", prep: "‚Äî", typical: "‚Äî" }
      }
    };

    const state = {
      project: {
        areas: [],
        settings: {
          vatIncluded: false,
          vatRate: 25,
          overageIncluded: false,
          overagePercent: 10,
          exactMode: false,
          stepMode: false,
          darkMode: false,
          hideDecimals: true,
          surfaceTypes: {
            "Smooth": 1.00,
            "Light Grind": 1.05,
            "Medium Grind": 1.10,
            "Rough": 1.15,
            "Porous/Cracked": 1.25
          },
          surfaceInfo: SURFACE_INFO[LANG]
        }
      },
      undoStack: [],
      redoStack: [],
      nextAreaId: 1,
      nextProductId: 1,
      nextTemplateId: 1,
      lastAddedProductTemplate: null
    };

    /* ================== DOM REFS ================== */
    const areasContainer = document.getElementById("areasContainer");
    const footerTotalLabel = document.getElementById("footerTotalLabel");
    const footerTotalValue = document.getElementById("footerTotalValue");
    const btnAddAreaDock = document.getElementById("btnAddAreaDock");
    const undoBtn = document.getElementById("undo");
    const redoBtn = document.getElementById("redo");
    const vatToggle = document.getElementById("vatToggle");
    const vatPercentInput = document.getElementById("vatPercent");
    const overageToggle = document.getElementById("overageToggle");
    const overagePercentInput = document.getElementById("overagePercent");
    const exactToggle = document.getElementById("exactToggle");
    const darkModeToggle = document.getElementById("darkModeToggle");
    const stepModeToggle = document.getElementById("stepModeToggle");
    const hideDecimalsToggle = document.getElementById("hideDecimalsToggle");
    const importBtn = document.getElementById("importData");
    const fileInput = document.getElementById("fileInput");
    const exportJSONBtn = document.getElementById("exportJSON");
    const exportCSVBtn = document.getElementById("exportCSV");
    const exportExcelBtn = document.getElementById("exportExcel");
    const shareLinkBtn = document.getElementById("shareLink");
    const printBtn = document.getElementById("printBtn");
    const infoBody = document.getElementById("infoBody");
    const infoToast = document.getElementById("infoToast");
    const lastInfoTime = document.getElementById("lastInfoTime");
    const hoverTip = document.getElementById("hoverTip");
    const btnScrollSummary = document.getElementById("btnScrollSummary");
    const logPanel = document.getElementById("logPanel");
    const logContent = document.getElementById("logContent");
    const minimizeLogBtn = document.getElementById("minimizeLog");
    const maximizeLogBtn = document.getElementById("maximizeLog");
    const langSV = document.getElementById("langSV");
    const langEN = document.getElementById("langEN");
    const topAddDock = document.getElementById("topAddDock");
    const productSuggestions = document.getElementById("productSuggestions");

    /* ================== UTIL & LOG ================== */
    function log(msg) {
      const tms = new Date().toLocaleTimeString();
      const p = document.createElement("p");
      p.textContent = `[${tms}] ${msg}`;
      logContent.appendChild(p);
      if (logContent.scrollHeight - logContent.clientHeight - logContent.scrollTop < 5) {
        logContent.scrollTop = logContent.scrollHeight;
      }
      const ud = state.undoStack.at(-1)?.desc || (LANG === "sv" ? "Inget att √•ngra" : "Nothing to undo");
      const rd = state.redoStack.at(-1)?.desc || (LANG === "sv" ? "Inget att g√∂ra om" : "Nothing to redo");
      undoBtn.title = (LANG === "sv" ? "√Öngra: " : "Undo: ") + ud;
      redoBtn.title = (LANG === "sv" ? "G√∂r om: " : "Redo: ") + rd;
    }

    function pushStateForUndo(desc) {
      const snap = JSON.parse(JSON.stringify(state.project));
      state.undoStack.push({ data: snap, desc });
      state.redoStack.length = 0;
      undoBtn.disabled = state.undoStack.length === 0;
      redoBtn.disabled = true;
      undoBtn.title = (LANG === "sv" ? "√Öngra: " : "Undo: ") + desc;
      redoBtn.title = (LANG === "sv" ? "G√∂r om: " : "Redo: ");
    }

    function undo() {
      if (!state.undoStack.length) return;
      const last = state.undoStack.pop();
      const desc = last.desc;
      state.redoStack.push({ data: JSON.parse(JSON.stringify(state.project)), desc });
      state.project = last.data;
      renderAll();
      log(`Undo: ${desc}`);
      undoBtn.disabled = state.undoStack.length === 0;
      redoBtn.disabled = state.redoStack.length === 0;
    }

    function redo() {
      if (!state.redoStack.length) return;
      const last = state.redoStack.pop();
      const desc = last.desc;
      state.undoStack.push({ data: JSON.parse(JSON.stringify(state.project)), desc });
      state.project = last.data;
      renderAll();
      log(`Redo: ${desc}`);
      undoBtn.disabled = state.undoStack.length === 0;
      redoBtn.disabled = state.redoStack.length === 0;
    }

    function toPosFloat(v, def) {
      const n = parseFloat(v);
      return (isNaN(n) || n < 0) ? def : n;
    }

    function fmt(n) {
      if (!isFinite(n)) return "0";
      if (state.project.settings.hideDecimals) return n.toFixed(0);
      if (Math.abs(n) >= 1000) return n.toFixed(0);
      if (Math.abs(n) >= 10) return n.toFixed(1);
      return n.toFixed(2);
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function formatCSVValue(v) {
      const s = String(v);
      return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
    }

    function escapeXML(s) {
      if (s == null) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    const showInfoToast = (() => {
      let hide = null;
      return () => {
        infoToast.style.display = "flex";
        if (hide) clearTimeout(hide);
        hide = setTimeout(() => infoToast.style.display = "none", 3500);
      };
    })();

    /* ================== SURFACE HELPERS ================== */
    function reverseFindTypeByFactor(f) {
      const m = Object.entries(state.project.settings.surfaceTypes).find(([_, v]) => Math.abs(v - f) < 1e-6);
      return m ? m[0] : null;
    }

    function surfaceExpl(area) {
      const k = reverseFindTypeByFactor(area.modifier) || "Custom";
      const meta = state.project.settings.surfaceInfo[k] || state.project.settings.surfaceInfo["Custom"];
      return {
        type: k,
        title: meta.title,
        desc: meta.desc,
        hint: meta.hint,
        prep: meta.prep,
        typical: meta.typical,
        factor: area.modifier.toFixed(2)
      };
    }

    /* ================== CANVAS ILLUSTRATION ================== */
    function baseConcreteColor(area) {
      const f = area.modifier;
      const l = 90 - Math.min(28, (f - 1) * 65);
      return `hsl(215 14% ${l}%)`;
    }

    function layerColor(p) {
      return p.color || (() => {
        let h = 0;
        const s = (p.name || "Layer");
        for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
        return `hsl(${h % 360} 70% 55%)`;
      })();
    }

    function drawAreaIllustration(canvas, area, highlightId = -1) {
      const ctx = canvas.getContext("2d");
      const W = canvas.width = canvas.clientWidth;
      const H = canvas.height = canvas.clientHeight;
      ctx.clearRect(0, 0, W, H);

      const baseX = W * 0.6;
      const depthX = W * 0.3;
      const depthY = W * 0.15;
      const slabHeightPx = 10;
      const layerHeightPx = 4;
      const marginLeft = 10;
      const marginBottom = 3;
      const slabBottomY = H - marginBottom;
      const originX = depthX + marginLeft;
      const originY = slabBottomY - slabHeightPx;

      const slabFrontLeft = { x: originX, y: originY };
      const slabFrontRight = { x: originX + baseX, y: originY };
      const slabBackLeft = { x: originX - depthX, y: originY - depthY };
      const slabBackRight = { x: originX + baseX - depthX, y: originY - depthY };
      const slabBottomFrontRight = { x: slabFrontRight.x, y: slabFrontRight.y + slabHeightPx };
      const slabBottomBackRight = { x: slabBackRight.x, y: slabBackRight.y + slabHeightPx };

      const sidePolys = [];
      let topPoly = null;

      sidePolys.push({
        id: 0,
        points: [{ ...slabBackRight }, { ...slabFrontRight }, { ...slabBottomFrontRight }, { ...slabBottomBackRight }],
        color: baseConcreteColor(area)
      });

      let curFrontLeft = slabFrontLeft;
      let curFrontRight = slabFrontRight;
      let curBackLeft = slabBackLeft;
      let curBackRight = slabBackRight;

      area.products.forEach(p => {
        const heightPx = (p.layers ? parseInt(p.layers) : 1) * layerHeightPx;
        const bottomFR = curFrontRight;
        const bottomBR = curBackRight;
        const newFrontLeft = { x: curFrontLeft.x, y: curFrontLeft.y - heightPx };
        const newFrontRight = { x: curFrontRight.x, y: curFrontRight.y - heightPx };
        const newBackLeft = { x: curBackLeft.x, y: curBackLeft.y - heightPx };
        const newBackRight = { x: curBackRight.x, y: curBackRight.y - heightPx };

        sidePolys.push({
          id: p.id,
          points: [{ ...newBackRight }, { ...newFrontRight }, { ...bottomFR }, { ...bottomBR }],
          color: layerColor(p)
        });

        curFrontLeft = newFrontLeft;
        curFrontRight = newFrontRight;
        curBackLeft = newBackLeft;
        curBackRight = newBackRight;
      });

      if (area.products.length > 0) {
        const topProduct = area.products[area.products.length - 1];
        topPoly = {
          id: topProduct.id,
          points: [{ ...curFrontLeft }, { ...curFrontRight }, { ...curBackRight }, { ...curBackLeft }],
          color: layerColor(topProduct)
        };
      } else {
        topPoly = {
          id: 0,
          points: [{ ...curFrontLeft }, { ...curFrontRight }, { ...curBackRight }, { ...curBackLeft }],
          color: baseConcreteColor(area)
        };
      }

      canvas._sidePolys = sidePolys;
      canvas._topPoly = topPoly;

      sidePolys.forEach(poly => {
        ctx.beginPath();
        const pts = poly.points;
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i].x, pts[i].y);
        }
        ctx.closePath();
        if (highlightId !== -1 && ((poly.id === 0 && highlightId === 0) || (poly.id > 0 && poly.id === highlightId))) {
          ctx.save();
          ctx.fillStyle = poly.color;
          ctx.filter = "brightness(1.25)";
          ctx.fill();
          ctx.restore();
        } else {
          ctx.fillStyle = poly.color;
          ctx.fill();
        }
      });

      ctx.beginPath();
      const tp = topPoly.points;
      ctx.moveTo(tp[0].x, tp[0].y);
      for (let i = 1; i < tp.length; i++) {
        ctx.lineTo(tp[i].x, tp[i].y);
      }
      ctx.closePath();
      if (highlightId !== -1 && ((topPoly.id === 0 && highlightId === 0) || (topPoly.id > 0 && topPoly.id === highlightId))) {
        ctx.save();
        ctx.fillStyle = topPoly.color;
        ctx.filter = "brightness(1.25)";
        ctx.fill();
        ctx.restore();
      } else {
        ctx.fillStyle = topPoly.color;
        ctx.fill();
      }

      ctx.strokeStyle = "rgba(0,0,0,0.3)";
      ctx.lineWidth = 1;
      for (let i = 0; i < sidePolys.length - 1; i++) {
        const pts = sidePolys[i].points;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        ctx.lineTo(pts[1].x, pts[1].y);
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.moveTo(tp[0].x, tp[0].y);
      for (let i = 1; i < tp.length; i++) {
        ctx.lineTo(tp[i].x, tp[i].y);
      }
      ctx.closePath();
      ctx.stroke();

      const frontRightBase = { x: slabBottomFrontRight.x, y: slabBottomFrontRight.y };
      const frontRightTop = { x: curFrontRight.x, y: curFrontRight.y };
      ctx.beginPath();
      ctx.moveTo(frontRightBase.x, frontRightBase.y);
      ctx.lineTo(frontRightTop.x, frontRightTop.y);
      ctx.stroke();

      const backRightBase = { x: slabBottomBackRight.x, y: slabBottomBackRight.y };
      const backRightTop = { x: curBackRight.x, y: curBackRight.y };
      ctx.beginPath();
      ctx.moveTo(backRightBase.x, backRightBase.y);
      ctx.lineTo(backRightTop.x, backRightTop.y);
      ctx.stroke();
    }

    function attachCanvasInteractions(canvas, area, inlineRow) {
      const tip = hoverTip;
      const show = (html, x, y) => {
        tip.innerHTML = html;
        tip.style.display = "block";
        const pad = 10;
        tip.style.left = (x + pad) + "px";
        tip.style.top = (y + pad) + "px";
      };
      const hide = () => {
        tip.style.display = "none";
      };
      const showInline = (html) => {
        inlineRow.innerHTML = html;
        inlineRow.classList.add("show");
      };
      const hideInline = () => {
        inlineRow.classList.remove("show");
        inlineRow.innerHTML = "";
      };

      canvas.addEventListener("mousemove", (e) => {
        const r = canvas.getBoundingClientRect();
        const x = e.clientX - r.left;
        const y = e.clientY - r.top;
        let highlightId = -1;
        let hoverProduct = null;
        let onSlab = false;

        const topPoly = canvas._topPoly;
        const pointInPoly = (px, py, polyPts) => {
          let inside = false;
          for (let i = 0, j = polyPts.length - 1; i < polyPts.length; j = i++) {
            const xi = polyPts[i].x, yi = polyPts[i].y;
            const xj = polyPts[j].x, yj = polyPts[j].y;
            const intersect = ((yi > py) != (yj > py)) && (px <= (xj - xi) * (py - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
          }
          return inside;
        };

        if (topPoly && pointInPoly(x, y, topPoly.points)) {
          highlightId = topPoly.id;
          if (highlightId === 0) {
            onSlab = true;
          } else {
            hoverProduct = area.products.find(p => p.id === highlightId) || null;
          }
        } else {
          const sidePolys = canvas._sidePolys || [];
          for (let poly of sidePolys) {
            if (pointInPoly(x, y, poly.points)) {
              highlightId = poly.id;
              if (highlightId === 0) {
                onSlab = true;
              } else {
                hoverProduct = area.products.find(p => p.id === highlightId) || null;
              }
              break;
            }
          }
        }

        drawAreaIllustration(canvas, area, highlightId);

        if (hoverProduct) {
          const p = hoverProduct;
          const html = `<div><strong>${t("hoverProduct")}:</strong> ${p.name||"-"}</div><div>‚Ä¢ ${t("layers")}: ${p.layers||1} ‚Ä¢ ${t("thickness")}: ${p.thickness||0} mm</div><div>‚Ä¢ ${t("unit")}: ${p.packUnit||"kg"} ‚Ä¢ ${t("packSize")}: ${p.packSize||0}</div><div>‚Ä¢ ${(p.priceMode==='perKg')?t("priceKg"):t("pricePack")}: ${p.price||0}</div>`;
          show(html, e.clientX, e.clientY);
          hideInline();
        } else if (onSlab) {
          const meta = surfaceExpl(area);
          const html = `<strong>${t("hoverSurface")}:</strong> ${meta.title} (√ó${meta.factor}) ‚Äî ${meta.hint}. ${meta.desc}`;
          show(html, e.clientX, e.clientY);
          showInline(html);
        } else {
          hide();
          hideInline();
        }
      });

      canvas.addEventListener("mouseleave", () => {
        drawAreaIllustration(canvas, area, -1);
        hoverTip.style.display = "none";
        hideInline();
      });
    }

    /* ================== EL HELPER ================== */
    function el(tag, attrs = {}, txt) {
      const e = document.createElement(tag);
      Object.entries(attrs).forEach(([k, v]) => {
        if (k === "class") e.className = v;
        else if (k === "style") e.setAttribute("style", v);
        else e.setAttribute(k, v);
      });
      if (txt != null) e.textContent = txt;
      return e;
    }

    function cloneProductData(prod) {
      return JSON.parse(JSON.stringify({
        name: prod.name || "",
        color: prod.color || null,
        layers: prod.layers || 1,
        thickness: prod.thickness || 0,
        density: (prod.density === null ? null : prod.density || 0),
        packSize: prod.packSize || 1,
        packUnit: prod.packUnit || "kg",
        price: prod.price || 0,
        priceMode: prod.priceMode || "perPack",
        calcMode: prod.calcMode || "thickness",
        usagePerM2: prod.usagePerM2 || 0,
        coverSqmPerPack: prod.coverSqmPerPack || 0,
        coverLayersPerPack: prod.coverLayersPerPack || 1
      }));
    }

    /* ================== AREA UI ================== */
    function createAreaElement(area) {
      const wrap = el("div", { class: "area", "data-area-id": area.id });
      const header = el("div", { class: "area-header" });

      const nameI = el("input", { type: "text", value: area.name, placeholder: t("areaName") });
      nameI.addEventListener("change", () => {
        const old = area.name;
        area.name = nameI.value;
        log(`Renamed area "${old}" ‚Üí "${area.name}"`);
      });
      header.appendChild(nameI);

      const surfaceSel = el("select", { title: t("surface") });
      Object.keys(state.project.settings.surfaceTypes).concat(["Custom"]).forEach(n => {
        const o = el("option", { value: n });
        const surfInfo = state.project.settings.surfaceInfo[n];
        o.textContent = surfInfo ? surfInfo.title : n;
        surfaceSel.appendChild(o);
      });
      const matched = reverseFindTypeByFactor(area.modifier) || "Custom";
      surfaceSel.value = matched;
      header.appendChild(surfaceSel);

      const modI = el("input", { type: "number", step: "0.01", value: area.modifier });
      modI.disabled = (matched !== "Custom");
      header.appendChild(modI);

      const sizeWrap = el("div", { class: "unit-wrap" });
      const sizeI = el("input", { type: "number", min: "0", step: "0.1", value: area.size || 0, placeholder: t("size") });
      const unit = el("div", { class: "unit" }, t("sq"));
      sizeWrap.appendChild(sizeI);
      sizeWrap.appendChild(unit);
      header.appendChild(sizeWrap);

      const miniCap = el("div", { class: "mini-caption" }, `${t("prodInfo")} / ${t("projectInfo")}`);
      header.appendChild(miniCap);

      const mini = el("div", { class: "mini-illustration" });
      const canvas = document.createElement("canvas");
      mini.appendChild(canvas);
      header.appendChild(mini);

      const del = el("button", { class: "del-area", title: t("deleteArea") }, t("deleteArea"));
      del.addEventListener("click", () => removeArea(wrap));
      header.appendChild(del);

      wrap.appendChild(header);

      const table = el("table", { class: "area-table", "data-area-id": area.id });
      const thead = el("thead");
      const grp = el("tr");
      grp.appendChild(el("th", { class: "th-group", colspan: "11" }, t("prodInfo")));
      grp.appendChild(el("th", { class: "th-group", colspan: "5" }, t("projectInfo")));
      thead.appendChild(grp);

      const head = el("tr");
      ["", t("product"), t("color"), t("calc"), t("usage"), t("density"), t("packSize"), t("unit"), t("priceMode"), t("pricePack"), t("coverSqm"), t("coverLayers"),
        t("layers"), t("thickness"), t("needed"), t("packages"), t("cost")
      ].forEach(h => head.appendChild(el("th", {}, h)));
      thead.appendChild(head);
      table.appendChild(thead);

      const tbody = el("tbody");
      tbody.setAttribute("data-area-id", area.id);
      area.products.forEach((p) => tbody.appendChild(buildProductRow(area, p)));
      table.appendChild(tbody);

      const inlineInfo = el("div", { class: "surface-inline", "data-bind": "inlineSurface" });
      wrap.appendChild(table);
      wrap.appendChild(inlineInfo);

      const btnWrap = el("div", { class: "footer-buttons" });
      const addProdBtn = el("button", { class: "btn btn-primary btn-slim" }, t("addProduct"));
      addProdBtn.addEventListener("click", () => {
        const firstAdd = area.products.length === 0 && state.lastAddedProductTemplate;
        const frag = addProduct(area, tbody);
        if (firstAdd) {
          if (confirm(`Klona senaste produkt "${state.lastAddedProductTemplate.name}" till detta omr√•de?`)) {
            applyProductDataToRow(area, frag, state.lastAddedProductTemplate);
            log(`Cloned last product template to "${area.name}"`);
            updateCalculations(true);
          }
        }
      });
      btnWrap.appendChild(addProdBtn);

      const addAreaAfter = el("button", { class: "btn btn-primary btn-slim" }, t("addArea"));
      addAreaAfter.addEventListener("click", () => insertAreaAfter(area.id));
      btnWrap.appendChild(addAreaAfter);
      wrap.appendChild(btnWrap);

      function updateAreaInfoboxAndCanvas(showInline = false) {
        const meta = surfaceExpl(area);
        drawAreaIllustration(canvas, area);
        attachCanvasInteractions(canvas, area, inlineInfo);
        if (showInline) {
          inlineInfo.innerHTML = `<strong>${t("hoverSurface")}:</strong> ${meta.title} (√ó${meta.factor}) ‚Äî ${meta.hint}. ${meta.desc}`;
          inlineInfo.classList.add("show");
        }
      }
      updateAreaInfoboxAndCanvas();

      surfaceSel.addEventListener("change", () => {
        if (surfaceSel.value === "Custom") {
          modI.disabled = false;
        } else {
          area.modifier = state.project.settings.surfaceTypes[surfaceSel.value];
          modI.value = area.modifier;
          modI.disabled = true;
          log(`Surface "${area.name}" ‚Üí ${surfaceSel.value} (x${area.modifier})`);
          updateCalculations(true);
        }
        updateAreaInfoboxAndCanvas(true);
      });
      surfaceSel.addEventListener("mouseenter", () => updateAreaInfoboxAndCanvas(true));
      surfaceSel.addEventListener("mouseleave", () => {
        inlineInfo.classList.remove("show");
        inlineInfo.innerHTML = "";
      });

      modI.addEventListener("change", () => {
        const v = toPosFloat(modI.value, 1.0);
        modI.value = v;
        area.modifier = v;
        surfaceSel.value = reverseFindTypeByFactor(v) || "Custom";
        if (surfaceSel.value !== "Custom") {
          modI.disabled = true;
        }
        log(`Surface factor "${area.name}" ‚Üí ${v}`);
        updateCalculations(true);
        updateAreaInfoboxAndCanvas(true);
      });

      const sizeIChange = () => {
        const v = toPosFloat(sizeI.value, 0);
        sizeI.value = v;
        area.size = v;
        log(`Area size "${area.name}" ‚Üí ${v} m¬≤`);
        updateCalculations();
      };
      sizeI.addEventListener("change", sizeIChange);

      enableDragSort(tbody, area);

      return wrap;
    }

    function buildProductRow(area, product) {
      if (!product.calcMode) product.calcMode = "thickness";
      if (product.usagePerM2 == null) product.usagePerM2 = 0;
      if (product.coverSqmPerPack == null) product.coverSqmPerPack = 0;
      if (product.coverLayersPerPack == null || product.coverLayersPerPack <= 0) product.coverLayersPerPack = 1;
      if (!product.priceMode) product.priceMode = "perPack";

      const tr = el("tr", { class: "product-row", "data-product-id": product.id, draggable: "true" });
      const td = (child, cls) => {
        const c = document.createElement("td");
        if (cls) c.className = cls;
        c.appendChild(child);
        return c;
      };

      const drag = el("span", { class: "drag-handle", title: "Drag to reorder" }, "‚ò∞");
      tr.appendChild(td(drag, "td-prod"));

      // Product Name with Datalist
      const nameI = el("input", { type: "text", value: product.name, placeholder: t("product"), list: "productSuggestions" });
      nameI.addEventListener("change", () => {
        product.name = nameI.value;
        state.lastAddedProductTemplate = cloneProductData(product);
        log(`Renamed product ${product.id} in "${area.name}" ‚Üí "${product.name}"`);
      });

      // Auto-fill logic
      nameI.addEventListener("input", (e) => {
        const val = e.target.value;
        const match = PRELOADED_PRODUCTS.find(p => p.name === val);
        if (match) {
          // Update product data
          Object.assign(product, cloneProductData(match));
          product.id = parseInt(tr.getAttribute("data-product-id")); // Restore ID
          // Update UI fields
          colorI.value = product.color || "#6cb2ff";
          mode.value = product.calcMode;
          usageI.value = product.usagePerM2;
          densI.value = product.density || "";
          packI.value = product.packSize;
          unitSel.value = product.packUnit;
          priceModeSel.value = product.priceMode;
          priceI.value = product.price;
          coverSqmI.value = product.coverSqmPerPack;
          coverLayersI.value = product.coverLayersPerPack;
          layersI.value = product.layers;
          thickI.value = product.thickness;
          // Trigger updates
          bindModeUI();
          updateCalculations(true);
          const canv = document.querySelector(`.area[data-area-id="${area.id}"] .mini-illustration canvas`);
          if (canv) drawAreaIllustration(canv, area);
        }
      });
      tr.appendChild(td(nameI, "td-prod"));

      const colorI = el("input", { type: "color", value: product.color || "#6cb2ff", title: t("color") });
      colorI.addEventListener("input", () => {
        product.color = colorI.value;
        const canv = document.querySelector(`.area[data-area-id="${area.id}"] .mini-illustration canvas`);
        if (canv) drawAreaIllustration(canv, area);
      });
      tr.appendChild(td(colorI, "td-prod"));

      const mode = el("select");
      [
        ["thickness", t("calcThickness")],
        ["usage", t("calcUsage")],
        ["coverage", t("calcCoverage")]
      ].forEach(([v, l]) => {
        const o = el("option", { value: v });
        o.textContent = l;
        mode.appendChild(o);
      });
      mode.value = product.calcMode;
      tr.appendChild(td(mode, "td-prod"));

      const usageI = el("input", { type: "number", min: "0", step: "0.001", value: product.usagePerM2 || 0, title: t("usageHint") });
      tr.appendChild(td(usageI, "td-prod"));

      const densI = el("input", { type: "number", min: "0", step: "0.01", value: (product.density ?? "") });
      densI.placeholder = t("density");
      tr.appendChild(td(densI, "td-prod"));

      const packI = el("input", { type: "number", min: "0.0001", step: "0.1", value: product.packSize || 1 });
      packI.addEventListener("change", () => {
        product.packSize = Math.max(0.0001, parseFloat(packI.value) || 1);
        packI.value = product.packSize;
        log(`Pack size "${product.name}" ‚Üí ${product.packSize} ${product.packUnit}`);
        updateCalculations();
      });
      tr.appendChild(td(packI, "td-prod"));

      const unitSel = el("select");
      ["kg", "L"].forEach(u => {
        const o = el("option", { value: u });
        o.textContent = u;
        unitSel.appendChild(o);
      });
      unitSel.value = product.packUnit || "kg";
      tr.appendChild(td(unitSel, "td-prod"));

      const priceModeSel = el("select");
      [
        ["perPack", t("perPack")],
        ["perKg", t("perKg")]
      ].forEach(([v, l]) => {
        const o = el("option", { value: v });
        o.textContent = l;
        priceModeSel.appendChild(o);
      });
      priceModeSel.value = product.priceMode;
      tr.appendChild(td(priceModeSel, "td-prod"));

      const priceI = el("input", { type: "number", min: "0", step: "0.01", value: product.price || 0, placeholder: t("pricePack") });
      tr.appendChild(td(priceI, "td-prod"));

      const coverSqmI = el("input", { type: "number", min: "0", step: "0.1", value: product.coverSqmPerPack || 0 });
      tr.appendChild(td(coverSqmI, "td-prod"));

      const coverLayersI = el("input", { type: "number", min: "1", step: "1", value: product.coverLayersPerPack || 1 });
      tr.appendChild(td(coverLayersI, "td-prod"));

      const layersI = el("input", { type: "number", min: "1", step: "1", value: product.layers || 1 });
      layersI.addEventListener("change", () => {
        product.layers = Math.max(1, parseInt(layersI.value) || 1);
        layersI.value = product.layers;
        log(`Layers "${product.name}" ‚Üí ${product.layers}`);
        updateCalculations();
      });
      tr.appendChild(td(layersI, "td-proj"));

      const thickI = el("input", { type: "number", min: "0", step: "0.1", value: product.thickness || 0 });
      thickI.addEventListener("change", () => {
        product.thickness = toPosFloat(thickI.value, 0);
        thickI.value = product.thickness;
        log(`Thickness "${product.name}" ‚Üí ${product.thickness} mm`);
        updateCalculations();
      });
      tr.appendChild(td(thickI, "td-proj"));

      const needSpan = el("span", { class: "neededQty" }, "0");
      tr.appendChild(td(needSpan, "td-proj"));
      const pkgSpan = el("span", { class: "packageCount" }, "0");
      tr.appendChild(td(pkgSpan, "td-proj"));
      const costSpan = el("span", { class: "cost" }, "0");
      tr.appendChild(td(costSpan, "td-proj"));

      const overlay = el("div", { class: "row-actions-overlay" });
      const cloneAll = el("button", { class: "mini ghost", "data-i18n": "cloneAll" }, t("cloneAll"));
      const cloneBelow = el("button", { class: "mini ghost", "data-i18n": "cloneBelow" }, t("cloneBelow"));
      const infoBtn = el("button", { class: "mini warn", "data-i18n": "breakdown" }, t("breakdown"));
      const delBtn = el("button", { class: "mini danger", "data-i18n": "remove" }, t("remove"));
      overlay.appendChild(cloneAll);
      overlay.appendChild(cloneBelow);
      overlay.appendChild(infoBtn);
      overlay.appendChild(delBtn);
      tr.appendChild(overlay);

      const br = document.createElement("tr");
      br.className = "breakdown";
      const brtd = document.createElement("td");
      brtd.colSpan = 16;
      br.appendChild(brtd);
      const brbox = el("div", { class: "breakdown" });
      brtd.appendChild(brbox);

      function bindModeUI() {
        const M = product.calcMode;
        const isUsage = (M === "usage");
        const isThick = (M === "thickness");
        const isCover = (M === "coverage");

        usageI.disabled = !isUsage;
        usageI.title = (!isUsage ? (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="thickness"?"calcThickness":"calcCoverage")}"` : `Not used in "${t(M==="thickness"?"calcThickness":"calcCoverage")}" mode`) : "");

        thickI.disabled = !isThick;
        thickI.title = (!isThick ? (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="usage"?"calcUsage":"calcCoverage")}"` : `Not used in "${t(M==="usage"?"calcUsage":"calcCoverage")}" mode`) : "");

        densI.disabled = (M !== "thickness") || (unitSel.value === "L");
        if (densI.disabled) {
          if (M === "thickness" && unitSel.value === "L") {
            densI.title = LANG === "sv" ? "Ej till√§mplig f√∂r volymbaserad ber√§kning" : "Not used for volume-based calculation";
          } else {
            densI.title = (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="usage"?"calcUsage":"calcCoverage")}"` : `Not used in "${t(M==="usage"?"calcUsage":"calcCoverage")}" mode`);
          }
        } else {
          densI.title = "";
        }

        coverSqmI.disabled = !isCover;
        coverSqmI.title = (!isCover ? (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="thickness"?"calcThickness":"calcUsage")}"` : `Not used in "${t(M==="thickness"?"calcThickness":"calcUsage")}" mode`) : "");
        coverLayersI.disabled = !isCover;
        coverLayersI.title = coverSqmI.title;
      }
      bindModeUI();

      const applyCalc = () => updateCalculations();
      unitSel.addEventListener("change", () => {
        product.packUnit = unitSel.value;
        bindModeUI();
        log(`Unit "${product.name}" ‚Üí ${product.packUnit}`);
        applyCalc();
      });
      mode.addEventListener("change", () => {
        product.calcMode = mode.value;
        bindModeUI();
        log(`Mode "${product.name}" ‚Üí ${product.calcMode}`);
        updateCalculations(true);
      });
      usageI.addEventListener("change", () => {
        product.usagePerM2 = toPosFloat(usageI.value, 0);
        usageI.value = product.usagePerM2;
        state.lastAddedProductTemplate = cloneProductData(product);
        applyCalc();
      });
      densI.addEventListener("change", () => {
        const v = toPosFloat(densI.value, 0);
        product.density = (densI.value === "" ? null : v);
        applyCalc();
      });
      coverSqmI.addEventListener("change", () => {
        product.coverSqmPerPack = toPosFloat(coverSqmI.value, 0);
        applyCalc();
      });
      coverLayersI.addEventListener("change", () => {
        product.coverLayersPerPack = Math.max(1, parseInt(coverLayersI.value) || 1);
        coverLayersI.value = product.coverLayersPerPack;
        applyCalc();
      });
      priceModeSel.addEventListener("change", () => {
        product.priceMode = priceModeSel.value;
        priceI.placeholder = (product.priceMode === 'perKg') ? t("priceKg") : t("pricePack");
        applyCalc();
      });
      priceI.addEventListener("change", () => {
        product.price = toPosFloat(priceI.value, 0);
        priceI.value = product.price.toFixed(2);
        log(`Price "${product.name}" ‚Üí ${product.price} (${product.priceMode})`);
        applyCalc();
      });
      delBtn.addEventListener("click", () => removeProduct(area, product.id));
      cloneAll.addEventListener("click", () => {
        pushStateForUndo(`Clone "${product.name}" to all areas`);
        state.project.areas.forEach(a => {
          if (a.id !== area.id) {
            const c = cloneProductData(product);
            c.id = state.nextProductId++;
            a.products.push(c);
          }
        });
        log(`Cloned "${product.name}" to all areas`);
        renderAll();
      });
      cloneBelow.addEventListener("click", () => {
        pushStateForUndo(`Clone "${product.name}" to areas below`);
        const idxA = state.project.areas.findIndex(a => a.id === area.id);
        state.project.areas.slice(idxA + 1).forEach(a => {
          const c = cloneProductData(product);
          c.id = state.nextProductId++;
          a.products.push(c);
        });
        log(`Cloned "${product.name}" to areas below`);
        renderAll();
      });
      infoBtn.addEventListener("click", () => {
        state.project.settings.stepMode = !state.project.settings.stepMode;
        stepModeToggle.checked = state.project.settings.stepMode;
        document.body.classList.toggle("step-on", state.project.settings.stepMode);
        updateCalculations(true);
      });

      const frag = document.createDocumentFragment();
      frag.appendChild(tr);
      frag.appendChild(br);
      return frag;
    }

    function addProduct(area, tbody) {
      const p = {
        id: state.nextProductId++,
        name: "",
        color: null,
        layers: 1,
        thickness: 0,
        density: null,
        packSize: 1,
        packUnit: "kg",
        price: 0,
        priceMode: "perPack",
        calcMode: "thickness",
        usagePerM2: 0,
        coverSqmPerPack: 0,
        coverLayersPerPack: 1
      };
      area.products.push(p);
      const frag = buildProductRow(area, p);
      tbody.appendChild(frag);
      log(`Added product in "${area.name}" (ID ${p.id})`);
      pushStateForUndo(`Added product in area ${area.name}`);
      updateCalculations();
      return frag;
    }

    function applyProductDataToRow(area, frag, data) {
      const prod = area.products[area.products.length - 1];
      Object.assign(prod, cloneProductData(data));
      const areaEl = areasContainer.querySelector(`.area[data-area-id="${area.id}"]`);
      if (areaEl) {
        areaEl.replaceWith(createAreaElement(area));
      }
    }

    function insertAreaAfter(areaId) {
      const idx = state.project.areas.findIndex(a => a.id === areaId);
      const id = state.nextAreaId++;
      const nm = (LANG === "sv" ? "Omr√•de " : "Area ") + id;
      const a = { id, name: nm, modifier: state.project.settings.surfaceTypes["Smooth"], size: 0, products: [] };
      pushStateForUndo(`Insert area after ${areaId}`);
      state.project.areas.splice(idx + 1, 0, a);
      renderAll();
      log(`Added area "${nm}"`);
    }

    function removeArea(areaElem) {
      const id = parseInt(areaElem.dataset.areaId);
      const idx = state.project.areas.findIndex(a => a.id === id);
      if (idx === -1) return;
      const nm = state.project.areas[idx].name || `Area ${id}`;
      pushStateForUndo(`Removed area ${nm}`);
      state.project.areas.splice(idx, 1);
      areaElem.remove();
      log(`Removed area "${nm}"`);
      updateCalculations(true);
      if (state.project.areas.length === 0) {
        topAddDock.style.display = "flex";
      }
    }

    function removeProduct(area, prodId) {
      const i = area.products.findIndex(p => p.id === prodId);
      if (i === -1) return;
      const nm = area.products[i].name || "(unnamed)";
      area.products.splice(i, 1);
      const areaEl = areasContainer.querySelector(`.area[data-area-id="${area.id}"]`);
      if (areaEl) {
        areaEl.querySelectorAll(`tr.product-row[data-product-id="${prodId}"], tr.breakdown`).forEach(r => r.remove());
      }
      log(`Removed product "${nm}" from "${area.name}"`);
      pushStateForUndo(`Removed product from area ${area.name}`);
      updateCalculations(true);
    }

    /* ================== DRAG SORT ================== */
    function enableDragSort(tbody, area) {
      let dragId = null;
      tbody.addEventListener("dragstart", (e) => {
        const row = e.target.closest(".product-row");
        if (!row) return;
        dragId = parseInt(row.getAttribute("data-product-id"));
        row.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        const areaElem = document.querySelector(`.area[data-area-id="${area.id}"]`);
        const canv = areaElem ? areaElem.querySelector(".mini-illustration canvas") : null;
        if (canv) drawAreaIllustration(canv, area);
      });
      tbody.addEventListener("dragend", (e) => {
        const row = e.target.closest(".product-row");
        if (row) row.classList.remove("dragging");
      });
      tbody.addEventListener("dragover", (e) => {
        e.preventDefault();
        const after = getDragAfterElement(tbody, e.clientY);
        const dragging = tbody.querySelector(".product-row.dragging");
        if (!dragging) return;
        if (after == null) tbody.appendChild(dragging);
        else tbody.insertBefore(dragging, after);
      });
      tbody.addEventListener("drop", () => {
        if (dragId == null) return;
        const order = [...tbody.querySelectorAll(".product-row")].map(r => parseInt(r.getAttribute("data-product-id")));
        const newProducts = order.map(id => area.products.find(p => p.id === id));
        if (newProducts.every(Boolean)) {
          pushStateForUndo(`Reorder products in ${area.name}`);
          area.products = newProducts;
          renderAll();
          log(`Reordered products in "${area.name}"`);
        }
        dragId = null;
      });
    }

    function getDragAfterElement(container, y) {
      const els = [...container.querySelectorAll(".product-row:not(.dragging)")];
      return els.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    /* ================== CALCULATIONS ================== */
    function refreshSummaryLabels() {
      const S = state.project.settings;
      const label = S.vatIncluded ?
        (LANG === "sv" ? "Projektets totalsumma (inkl. moms):" : "Project total (incl. VAT):") :
        (LANG === "sv" ? "Projektets totalsumma (exkl. moms):" : "Project total (excl. VAT):");
      footerTotalLabel.textContent = label;
    }

    function updateCalculations(fromSurface = false) {
      const S = state.project.settings;
      let totalCostExVAT = 0;
      const totalsMap = new Map();

      state.project.areas.forEach(area => {
        let areaCost = 0;
        const areaEl = areasContainer.querySelector(`.area[data-area-id="${area.id}"]`);
        const rows = areaEl ? areaEl.querySelectorAll("tbody tr.product-row") : [];

        area.products.forEach((p, idx) => {
          const areaSize = Number(area.size) || 0;
          const layers = Math.max(1, Number(p.layers) || 1);
          const unit = p.packUnit || "kg";
          const price = Number(p.price) || 0;
          const pack = Math.max(0.0001, Number(p.packSize) || 0);
          const priceMode = p.priceMode || "perPack";

          let neededUnits = 0;
          let packages = 0;
          let breakdown = [];

          if (p.calcMode === "usage") {
            const use = Number(p.usagePerM2) || 0;
            let base = areaSize * layers * use;
            breakdown.push(`Base = Area(${areaSize}) √ó Layers(${layers}) √ó Usage(${use}/${unit}¬∑m¬≤) = ${fmt(base)}`);
            base *= area.modifier;
            breakdown.push(`√ó Surface ${area.modifier} ‚áí ${fmt(base)}`);
            if (S.overageIncluded) {
              base *= (1 + S.overagePercent / 100);
              breakdown.push(`+ Overage ${S.overagePercent}% ‚áí ${fmt(base)}`);
            }
            neededUnits = base;
            packages = S.exactMode ? (neededUnits / pack) : Math.ceil(neededUnits / pack);

          } else if (p.calcMode === "thickness") {
            const th = Number(p.thickness) || 0;
            let volL = areaSize * th * layers;
            breakdown.push(`Volume L = Area(${areaSize}) √ó Thickness(${th}) √ó Layers(${layers}) = ${fmt(volL)} L`);
            volL *= area.modifier;
            breakdown.push(`√ó Surface ${area.modifier} ‚áí ${fmt(volL)} L`);
            if (S.overageIncluded) {
              volL *= (1 + S.overagePercent / 100);
              breakdown.push(`+ Overage ${S.overagePercent}% ‚áí ${fmt(volL)} L`);
            }
            if (unit === "kg") {
              const dens = Number(p.density) || 0;
              if (dens > 0) {
                neededUnits = volL * dens;
                breakdown.push(`Needed kg = ${fmt(volL)} √ó ${dens} = ${fmt(neededUnits)} kg`);
              } else {
                neededUnits = 0;
                breakdown.push(`Density missing ‚áí 0 kg`);
              }
            } else {
              neededUnits = volL;
              breakdown.push(`Needed L = ${fmt(neededUnits)} L`);
            }
            packages = S.exactMode ? (neededUnits / pack) : Math.ceil(neededUnits / pack);

          } else { // coverage
            const cov = Number(p.coverSqmPerPack) || 0;
            const covLayers = Math.max(1, Number(p.coverLayersPerPack) || 1);
            const packsNeeded = cov > 0 ? (areaSize * (layers / covLayers) / cov) : 0;
            packages = S.exactMode ? packsNeeded : Math.ceil(packsNeeded);
            neededUnits = packages * pack;
            breakdown.push(`Packs = Area(${areaSize}) √ó (Layers ${layers}/${covLayers}) √∑ ${cov} = ${fmt(packsNeeded)} ${S.exactMode?"(exact)":""}`);
            breakdown.push(`Units = Packs √ó PackSize = ${fmt(packages)} √ó ${pack} = ${fmt(neededUnits)} ${unit}`);
          }

          const cost = (priceMode === 'perKg') ? (neededUnits * price) : (packages * price);
          areaCost += cost;

          const prodRow = rows[idx];
          if (prodRow) {
            const needSpan = prodRow.querySelector(".neededQty");
            const pkgSpan = prodRow.querySelector(".packageCount");
            const costSpan = prodRow.querySelector(".cost");
            if (needSpan) needSpan.textContent = neededUnits ? `${fmt(neededUnits)} ${unit}` : "0";
            if (pkgSpan) pkgSpan.textContent = S.exactMode ? fmt(packages) : String(packages || 0);
            if (costSpan) costSpan.textContent = state.project.settings.hideDecimals ? cost.toFixed(0) : cost.toFixed(2);

            const brRow = prodRow.nextElementSibling;
            if (brRow && brRow.querySelector(".breakdown")) {
              const box = brRow.querySelector(".breakdown");
              box.innerHTML = `
                <div><strong>${p.name||"Product"} ‚Äî ${p.calcMode} ‚Äî ${(p.priceMode==='perKg')?t("priceKg"):t("pricePack")}</strong></div>
                <div>${breakdown.join("<br/>")}</div>
                <div><strong>Cost</strong> = ${(p.priceMode==='perKg')?'Needed √ó Price/kg':'Packages √ó Price/pack'} = ${(p.priceMode==='perKg')?fmt(neededUnits): (S.exactMode?fmt(packages):packages)} √ó ${price} = <strong>${state.project.settings.hideDecimals?cost.toFixed(0):cost.toFixed(2)}</strong></div>
              `;
              brRow.style.display = S.stepMode ? "" : "none";
            }
          }

          const key = (p.name || "(unnamed)") + "|" + unit;
          const rec = totalsMap.get(key) || { name: (p.name || "(unnamed)"), unit, needed: 0, pack: pack, price: price, priceMode: priceMode, exactPackages: 0 };
          rec.needed += neededUnits;
          rec.exactPackages += (neededUnits / pack);
          totalsMap.set(key, rec);
        });

        totalCostExVAT += areaCost;
        const canv = areasContainer.querySelector(`.area[data-area-id="${area.id}"] .mini-illustration canvas`);
        if (canv) drawAreaIllustration(canv, area);
      });

      const label = state.project.settings.vatIncluded ?
        (LANG === "sv" ? "Projektets totalsumma (inkl. moms):" : "Project total (incl. VAT):") :
        (LANG === "sv" ? "Projektets totalsumma (exkl. moms):" : "Project total (excl. VAT):");
      footerTotalLabel.textContent = label;
      const totalDisplay = state.project.settings.vatIncluded ? totalCostExVAT * (1 + state.project.settings.vatRate / 100) : totalCostExVAT;
      footerTotalValue.textContent = state.project.settings.hideDecimals ? totalDisplay.toFixed(0) : totalDisplay.toFixed(2);

      renderTotalsInfo(totalsMap, state.project.settings);

      if (fromSurface) {
        lastInfoTime.textContent = t("updated") + new Date().toLocaleTimeString();
        showInfoToast();
      }
    }

    function renderTotalsInfo(totalsMap, S) {
      const arr = [...totalsMap.values()];
      const info = document.getElementById("infoBody");
      if (!arr.length) {
        info.innerHTML = `
        <div class="info-card" id="moistureCard">
          <strong>Fukt & fuktighet</strong>
          <p style="margin:.4em 0 .2em 0; color:var(--muted)">
            H√∂g fukthalt i underlag/luft kan √∂ka √•tg√•ngen och f√∂rl√§nga torktider. Torka och dammsug ytan noga. F√∂lj databladens klimatkrav.
            <em>(Informativt ‚Äî p√•verkar inte ber√§kning automatiskt.)</em>
          </p>
        </div>
        <em>${t("infoEmpty")}</em>`;
        return;
      }
      const parts = [
        `<div class="info-card" id="moistureCard">
          <strong>Fukt & fuktighet</strong>
          <p style="margin:.4em 0 .2em 0; color:var(--muted)">
            H√∂g fukthalt i underlag/luft kan √∂ka √•tg√•ngen och f√∂rl√§nga torktider. Torka och dammsug ytan noga. F√∂lj databladens klimatkrav.
            <em>(Informativt ‚Äî p√•verkar inte ber√§kning automatiskt.)</em>
          </p>
        </div>`
      ];
      arr.forEach(rec => {
        const exactPk = rec.exactPackages;
        const roundedPk = Math.ceil(exactPk);
        const recommendedPk = roundedPk + 1;
        const exactCost = (rec.priceMode === 'perKg') ? (rec.needed * rec.price) : (exactPk * rec.price);
        const roundedCost = (rec.priceMode === 'perKg') ? (rec.needed * rec.price) : (roundedPk * rec.price);
        const recommendedCost = (rec.priceMode === 'perKg') ? (rec.needed * rec.price) : (recommendedPk * rec.price);

        const exactCostDisplay = state.project.settings.hideDecimals ? exactCost.toFixed(0) : exactCost.toFixed(2);
        const roundedCostDisplay = state.project.settings.hideDecimals ? roundedCost.toFixed(0) : roundedCost.toFixed(2);
        const recommendedCostDisplay = state.project.settings.hideDecimals ? recommendedCost.toFixed(0) : recommendedCost.toFixed(2);

        parts.push(`
          <div class="product-total">
            <h5>${rec.name} <span class="dim">[${rec.unit}]</span></h5>
            <div>${LANG==="sv"?"Totalt behov":"Total need"}: <strong>${fmt(rec.needed)} ${rec.unit}</strong></div>
            <div>${LANG==="sv"?"F√∂rpackningar":"Packages"}: ${LANG==="sv"?"exakt":"exact"} ${fmt(exactPk)}, ${LANG==="sv"?"avrundat":"rounded"} ${roundedPk}, <em>${LANG==="sv"?"rekommenderat":"recommended"}</em> ${recommendedPk} (${LANG==="sv"?"ta lite extra f√∂r s√§kerhets skull":"take a little extra for safety"})</div>
            <div>${LANG==="sv"?"Kostnad":"Cost"} (${rec.priceMode==='perKg'?(LANG==="sv"?"pris/kg":"per kg"):(LANG==="sv"?"pris/f√∂rp":"per pack")}):
               ${LANG==="sv"?"exakt":"exact"} ${exactCostDisplay}, ${LANG==="sv"?"avrundat":"rounded"} ${roundedCostDisplay}, ${LANG==="sv"?"rekommenderat":"recommended"} ${recommendedCostDisplay}</div>
          </div>
        `);
      });
      info.innerHTML = parts.join("");
    }

    /* ================== RENDER ALL ================== */
    function renderAll() {
      areasContainer.innerHTML = "";
      state.project.areas.forEach(a => areasContainer.appendChild(createAreaElement(a)));

      vatToggle.checked = state.project.settings.vatIncluded;
      vatPercentInput.value = state.project.settings.vatRate;
      overageToggle.checked = state.project.settings.overageIncluded;
      overagePercentInput.value = state.project.settings.overagePercent;
      exactToggle.checked = state.project.settings.exactMode || false;
      stepModeToggle.checked = state.project.settings.stepMode || false;
      darkModeToggle.checked = state.project.settings.darkMode || false;
      hideDecimalsToggle.checked = state.project.settings.hideDecimals || false;
      document.body.classList.toggle("step-on", state.project.settings.stepMode);
      document.body.classList.toggle("dark-mode", state.project.settings.darkMode);

      renderTemplates();
      applyI18n();
      updateCalculations(true);

      topAddDock.style.display = state.project.areas.length ? "none" : "flex";

      const ud = state.undoStack.at(-1)?.desc || (LANG === "sv" ? "Inget att √•ngra" : "Nothing to undo");
      const rd = state.redoStack.at(-1)?.desc || (LANG === "sv" ? "Inget att g√∂ra om" : "Nothing to redo");
      undoBtn.title = (LANG === "sv" ? "√Öngra: " : "Undo: ") + ud;
      redoBtn.title = (LANG === "sv" ? "G√∂r om: " : "Redo: ") + rd;
      undoBtn.disabled = state.undoStack.length === 0;
      redoBtn.disabled = state.redoStack.length === 0;
    }

    /* ================== TEMPLATES ================== */
    const TKEY = "__TEMPLATES__";

    function getTemplates() {
      if (!state._templates) state._templates = [];
      return state._templates;
    }

    function saveTemplates() {
      localStorage.setItem(TKEY, JSON.stringify(getTemplates()));
    }

    function loadTemplates() {
      try {
        const raw = localStorage.getItem(TKEY);
        if (raw) {
          const arr = JSON.parse(raw) || [];
          state._templates = arr;
          state.nextTemplateId = (Math.max(0, ...arr.map(x => x.id || 0)) + 1) || 1;
        }
      } catch {
        state._templates = [];
      }
    }

    function renderTemplates() {
      const templatesBody = document.getElementById("templatesBody");
      templatesBody.innerHTML = "";
      const list = getTemplates();
      if (!list.length) {
        templatesBody.innerHTML = `<div style="color:var(--muted)">${LANG==="sv"?"Inga mallar √§nnu.":"No templates yet."}</div>`;
        return;
      }
      list.forEach(t => {
        const row = el("div", { style: "display:grid;grid-template-columns: 200px 80px 140px 120px 120px 110px 110px 90px 130px 120px 120px 120px auto;gap:8px;align-items:center;margin:6px 0" });
        const n = el("input", { value: t.name, placeholder: t("product") });
        row.appendChild(n);
        const color = el("input", { type: "color", value: t.color || "#6cb2ff" });
        row.appendChild(color);
        const mode = el("select");
        [
          ["thickness", t("calcThickness")],
          ["usage", t("calcUsage")],
          ["coverage", t("calcCoverage")]
        ].forEach(([v, l]) => {
          const o = el("option", { value: v });
          o.textContent = l;
          mode.appendChild(o);
        });
        mode.value = t.calcMode;
        row.appendChild(mode);
        const use = el("input", { type: "number", min: "0", step: "0.001", value: t.usagePerM2 || 0 });
        row.appendChild(use);
        const lay = el("input", { type: "number", min: "1", step: "1", value: t.layers || 1 });
        row.appendChild(lay);
        const th = el("input", { type: "number", min: "0", step: "0.1", value: t.thickness || 0 });
        row.appendChild(th);
        const de = el("input", { type: "number", min: "0", step: "0.01", value: (t.density ?? "") });
        row.appendChild(de);
        const ps = el("input", { type: "number", min: "0.0001", step: "0.1", value: t.packSize || 1 });
        row.appendChild(ps);
        const pu = el("select");
        ["kg", "L"].forEach(u => {
          const o = el("option", { value: u });
          o.textContent = u;
          pu.appendChild(o);
        });
        pu.value = t.packUnit || "kg";
        row.appendChild(pu);
        const pm = el("select");
        [
          ["perPack", t("perPack")],
          ["perKg", t("perKg")]
        ].forEach(([v, l]) => {
          const o = el("option", { value: v });
          o.textContent = l;
          pm.appendChild(o);
        });
        pm.value = t.priceMode || "perPack";
        row.appendChild(pm);
        const pr = el("input", { type: "number", min: "0", step: "0.01", value: t.price || 0 });
        row.appendChild(pr);
        const coverS = el("input", { type: "number", min: "0", step: "0.1", value: t.coverSqmPerPack || 0, placeholder: t("coverSqm") });
        row.appendChild(coverS);
        const coverL = el("input", { type: "number", min: "1", step: "1", value: t.coverLayersPerPack || 1, placeholder: t("coverLayers") });
        row.appendChild(coverL);

        const actions = el("div", { style: "display:flex;gap:8px;justify-content:flex-end" });
        const applyAll = el("button", { class: "btn" }, t("applyAllTemplates"));
        const applyCurrent = el("button", { class: "btn" }, LANG === "sv" ? "Anv√§nd p√• aktuellt omr√•de" : "Apply to current area");
        const del = el("button", { class: "btn", style: "border:1px solid var(--line)" }, "Delete");
        actions.appendChild(applyAll);
        actions.appendChild(applyCurrent);
        actions.appendChild(del);
        row.appendChild(actions);

        const bind = () => {
          t.name = n.value;
          t.color = color.value;
          t.calcMode = mode.value;
          t.usagePerM2 = toPosFloat(use.value, 0);
          t.layers = Math.max(1, parseInt(lay.value) || 1);
          t.thickness = toPosFloat(th.value, 0);
          t.density = (de.value === "" ? null : toPosFloat(de.value, 0));
          t.packSize = Math.max(0.0001, parseFloat(ps.value) || 1);
          t.packUnit = pu.value;
          t.price = toPosFloat(pr.value, 0);
          t.priceMode = pm.value;
          t.coverSqmPerPack = toPosFloat(coverS.value, 0);
          t.coverLayersPerPack = Math.max(1, parseInt(coverL.value) || 1);
        };
        [n, color, mode, use, lay, th, de, ps, pu, pm, pr, coverS, coverL].forEach(inp => inp.addEventListener("change", () => {
          bind();
          saveTemplates();
        }));

        applyAll.addEventListener("click", () => {
          bind();
          saveTemplates();
          pushStateForUndo(`Apply template "${t.name}" to all areas`);
          state.project.areas.forEach(a => {
            const np = cloneProductData(t);
            np.id = state.nextProductId++;
            a.products.push(np);
          });
          log(t("tmplApplyAll"));
          renderAll();
        });
        applyCurrent.addEventListener("click", () => {
          bind();
          saveTemplates();
          const a = state.project.areas[0];
          if (!a) {
            alert(LANG === "sv" ? "Skapa ett omr√•de f√∂rst." : "Create an area first.");
            return;
          }
          pushStateForUndo(`Apply template "${t.name}" to first area`);
          const np = cloneProductData(t);
          np.id = state.nextProductId++;
          a.products.push(np);
          renderAll();
        });
        del.addEventListener("click", () => {
          if (!confirm(LANG === "sv" ? "Ta bort mallen?" : "Delete this template?")) return;
          const L = getTemplates();
          const idx = L.findIndex(x => x.id === t.id);
          if (idx > -1) {
            L.splice(idx, 1);
            saveTemplates();
            renderTemplates();
          }
        });

        templatesBody.appendChild(row);
      });
    }

    /* ================== IMPORT / EXPORT / URL ================== */
    function importData(file, content) {
      const name = file.name;
      if (name.endsWith(".json")) {
        try {
          const parsed = JSON.parse(content);
          if (!parsed.areas || !parsed.settings) throw new Error("Invalid JSON format");
          pushStateForUndo(`Imported JSON (${name})`);
          state.project.areas = parsed.areas;
          state.project.settings = { ...state.project.settings,
            ...parsed.settings
          };
          state.nextAreaId = 1;
          state.nextProductId = 1;
          state.project.areas.forEach(a => {
            if (a.id >= state.nextAreaId) state.nextAreaId = a.id + 1;
            a.products.forEach(p => {
              if (p.id >= state.nextProductId) state.nextProductId = p.id + 1;
            });
          });
          renderAll();
          log(`Imported JSON "${name}"`);
        } catch (err) {
          alert("Failed to import JSON: " + err.message);
          log("Error importing JSON: " + err.message);
        }
      } else if (name.endsWith(".csv")) {
        try {
          const lines = content.split(/\r?\n/).filter(l => l.trim().length > 0);
          if (!lines.length) throw new Error("Empty CSV");
          let start = 0,
            headers = [];
          if (/area\s*name|areaname/i.test(lines[0])) {
            headers = parseCSVLine(lines[0]);
            start = 1;
          } else {
            headers = ["AreaName", "SurfaceType", "SurfaceMod", "AreaSize", "ProductName", "Color", "Layers", "Thickness", "Density", "PackSize", "PackUnit", "Price", "PriceMode", "VATIncluded", "VATRate", "OverageIncluded", "OveragePercent", "CalcMode", "UsagePerM2", "CoverSqmPerPack", "CoverLayersPerPack"];
          }
          const idx = {};
          headers.forEach((c, i) => idx[c] = i);
          const importedAreas = [];
          const map = {};
          let importedSettings = {};
          for (let i = start; i < lines.length; i++) {
            const v = parseCSVLine(lines[i]);
            if (!v.length) continue;
            const aName = v[idx["AreaName"] ?? 0] || "";
            if (!aName) continue;
            const sType = v[idx["SurfaceType"]] || "Custom";
            const sMod = parseFloat(v[idx["SurfaceMod"]]) || 1.0;
            const aSize = parseFloat(v[idx["AreaSize"]]) || 0;
            const pName = v[idx["ProductName"]] || "";
            const color = v[idx["Color"]] || null;
            const layers = parseInt(v[idx["Layers"]]) || 1;
            const thick = parseFloat(v[idx["Thickness"]]) || 0;
            const dens = (v[idx["Density"]] !== "" && v[idx["Density"]] != null) ? parseFloat(v[idx["Density"]]) : null;
            const pSize = parseFloat(v[idx["PackSize"]]) || 1;
            const pUnit = v[idx["PackUnit"]] || "kg";
            const price = parseFloat(v[idx["Price"]]) || 0;
            const pMode = v[idx["PriceMode"]] || "perPack";
            const mode = v[idx["CalcMode"]] || "thickness";
            const usage = parseFloat(v[idx["UsagePerM2"]]) || 0;
            const covS = parseFloat(v[idx["CoverSqmPerPack"]]) || 0;
            const covL = parseInt(v[idx["CoverLayersPerPack"]]) || 1;
            if (i === start) {
              importedSettings.vatIncluded = /^(true|1)$/i.test(v[idx["VATIncluded"]] || "");
              importedSettings.vatRate = parseFloat(v[idx["VATRate"]]) || state.project.settings.vatRate;
              importedSettings.overageIncluded = /^(true|1)$/i.test(v[idx["OverageIncluded"]] || "");
              importedSettings.overagePercent = parseFloat(v[idx["OveragePercent"]]) || state.project.settings.overagePercent;
            }
            let area = map[aName];
            if (!area) {
              area = { id: state.nextAreaId++, name: aName, modifier: sMod, size: aSize, products: [] };
              map[aName] = area;
              importedAreas.push(area);
            }
            if (pName || price > 0 || thick > 0) {
              area.products.push({
                id: state.nextProductId++,
                name: pName,
                color,
                layers,
                thickness: thick,
                density: dens,
                packSize: pSize,
                packUnit: pUnit,
                price,
                priceMode: pMode,
                calcMode: mode,
                usagePerM2: usage,
                coverSqmPerPack: covS,
                coverLayersPerPack: covL
              });
            }
          }
          pushStateForUndo(`Imported CSV (${name})`);
          state.project.areas = importedAreas;
          state.project.settings = { ...state.project.settings,
            ...importedSettings
          };
          renderAll();
          log(`Imported CSV "${name}"`);
        } catch (err) {
          alert("Failed to import CSV: " + err.message);
          log("Error importing CSV: " + err.message);
        }
      } else {
        alert(t("errUnsupported"));
        log("Import failed: unsupported file");
      }
    }

    function parseCSVLine(line) {
      const out = [];
      let cur = "";
      let q = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (!q) {
          if (ch === ',') {
            out.push(cur.trim());
            cur = "";
          } else if (ch === '"') {
            q = true;
          } else cur += ch;
        } else {
          if (ch === '"') {
            if (i + 1 < line.length && line[i + 1] === '"') {
              cur += '"';
              i++;
            } else q = false;
          } else cur += ch;
        }
      }
      out.push(cur.trim());
      return out;
    }

    function exportJSON() {
      const blob = new Blob([JSON.stringify(state.project, null, 2)], { type: "application/json" });
      downloadBlob(blob, "project_export.json");
      log("Exported JSON");
    }

    function exportCSV() {
      const headers = ["AreaName", "SurfaceType", "SurfaceMod", "AreaSize", "ProductName", "Color", "Layers", "Thickness", "Density", "PackSize", "PackUnit", "Price", "PriceMode", "VATIncluded", "VATRate", "OverageIncluded", "OveragePercent", "CalcMode", "UsagePerM2", "CoverSqmPerPack", "CoverLayersPerPack"];
      const lines = [headers.join(",")];
      const S = state.project.settings;
      state.project.areas.forEach(a => {
        if (!a.products.length) {
          lines.push([a.name, reverseFindTypeByFactor(a.modifier) || "Custom", a.modifier, a.size, "", "", "", "", "", "", "", "", "", S.vatIncluded, S.vatRate, S.overageIncluded, S.overagePercent, "", "", "", ""].map(formatCSVValue).join(","));
        } else {
          a.products.forEach(p => {
            lines.push([a.name, reverseFindTypeByFactor(a.modifier) || "Custom", a.modifier, a.size, p.name || "", p.color || "", p.layers, p.thickness, (p.density != null ? p.density : ""), p.packSize, p.packUnit, p.price, p.priceMode || "perPack", S.vatIncluded, S.vatRate, S.overageIncluded, S.overagePercent, p.calcMode, p.usagePerM2, p.coverSqmPerPack, p.coverLayersPerPack].map(formatCSVValue).join(","));
          });
        }
      });
      downloadBlob(new Blob([lines.join("\n")], { type: "text/csv" }), "project_export.csv");
      log("Exported CSV");
    }

    function generateExcelXML() {
      const nl = "\r\n";
      let xml = '<?xml version="1.0"?>' + nl + '<?mso-application progid="Excel.Sheet"?>' + nl + '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">' + nl + '<Styles>' + nl + '<Style ss:ID="Bold"><Font ss:Bold="1"/></Style>' + nl + '<Style ss:ID="TwoDec"><NumberFormat ss:Format="0.00"/></Style>' + nl + '<Style ss:ID="BoldTwoDec"><Font ss:Bold="1"/><NumberFormat ss:Format="0.00"/></Style>' + nl + '</Styles>' + nl + '<Worksheet ss:Name="Estimate">' + nl;
      const COLS = 20;
      let rows = 1;
      state.project.areas.forEach(a => {
        rows += a.products.length;
        rows += 1;
      });
      rows += 1;
      xml += `<Table ss:ExpandedColumnCount="${COLS}" ss:ExpandedRowCount="${rows}">` + nl;
      for (let j = 0; j < COLS; j++) {
        xml += '<Column ss:AutoFitWidth="1"/>' + nl;
      }
      const headers = ["Area", "Surface Mod", "Area Size (m¬≤)", "Product", "Color", "# Mode", "Usage kg/m¬≤", "Density kg/L", "Pack size", "Unit", "Price Mode", "Price", "Cover m¬≤/pack", "Cover layers/pack", "Layers", "Thickness (mm)", "Needed", "Packages", "Cost"];
      xml += '<Row ss:StyleID="Bold">' + nl;
      headers.forEach(h => xml += `<Cell><Data ss:Type="String">${h}</Data></Cell>` + nl);
      xml += '</Row>' + nl;
      let rowIndex = 1,
        areaTotalRows = [];
      state.project.areas.forEach(a => {
        a.products.forEach(p => {
          rowIndex++;
          const S = state.project.settings;
          const areaSize = Number(a.size) || 0,
            layers = Math.max(1, Number(p.layers) || 1),
            unit = p.packUnit || "kg",
            price = Number(p.price) || 0,
            packSize = Math.max(0.0001, Number(p.packSize) || 0),
            priceMode = p.priceMode || "perPack";
          let needed = 0,
            packages = 0;
          if ((p.calcMode || "thickness") === "usage") {
            let base = areaSize * layers * (Number(p.usagePerM2) || 0);
            base *= a.modifier;
            if (S.overageIncluded) base *= (1 + S.overagePercent / 100);
            needed = base;
            packages = S.exactMode ? needed / packSize : Math.ceil(needed / packSize);
          } else if (p.calcMode === "thickness") {
            let volL = areaSize * (Number(p.thickness) || 0) * layers;
            volL *= a.modifier;
            if (S.overageIncluded) volL *= (1 + S.overagePercent / 100);
            needed = (unit === "kg") ? ((Number(p.density) || 0) > 0 ? volL * (Number(p.density) || 0) : 0) : volL;
            packages = S.exactMode ? needed / packSize : Math.ceil(needed / packSize);
          } else {
            const cov = Number(p.coverSqmPerPack) || 0;
            const covL = Math.max(1, Number(p.coverLayersPerPack) || 1);
            const packNeed = cov > 0 ? (areaSize * (layers / covL) / cov) : 0;
            packages = S.exactMode ? packNeed : Math.ceil(packNeed);
            needed = packages * packSize;
          }
          const cost = (priceMode === 'perKg') ? (needed * price) : (packages * price);
          xml += '<Row>' + nl;
          xml += `<Cell><Data ss:Type="String">${escapeXML(a.name)}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${a.modifier}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${a.size}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="String">${escapeXML(p.name||"")}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="String">${escapeXML(p.color||"")}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="String">${p.calcMode}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${p.usagePerM2||0}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${(p.density!=null?p.density:"")}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${p.packSize||0}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="String">${unit}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="String">${priceMode}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${price}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${p.coverSqmPerPack||0}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${p.coverLayersPerPack||1}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${layers}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${p.thickness||0}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${needed.toFixed(1)}</Data></Cell>` + nl;
          xml += `<Cell><Data ss:Type="Number">${S.exactMode?fmt(packages):packages}</Data></Cell>` + nl;
          xml += `<Cell ss:StyleID="TwoDec"><Data ss:Type="Number">${cost.toFixed(2)}</Data></Cell>` + nl;
          xml += '</Row>' + nl;
        });
        rowIndex++;
        areaTotalRows.push(rowIndex);
        let areaTotal = 0;
        a.products.forEach(p => {
          const S = state.project.settings;
          const areaSize = Number(a.size) || 0;
          const layers = Math.max(1, Number(p.layers) || 1);
          const unit = p.packUnit || "kg";
          const price = Number(p.price) || 0;
          const packSize = Math.max(0.0001, Number(p.packSize) || 0);
          const priceMode = p.priceMode || "perPack";
          let needed = 0,
            packages = 0;
          if ((p.calcMode || "thickness") === "usage") {
            let base = areaSize * layers * (Number(p.usagePerM2) || 0);
            base *= a.modifier;
            if (S.overageIncluded) base *= (1 + S.overagePercent / 100);
            needed = base;
            packages = S.exactMode ? needed / packSize : Math.ceil(needed / packSize);
          } else if (p.calcMode === "thickness") {
            let volL = areaSize * (Number(p.thickness) || 0) * layers;
            volL *= a.modifier;
            if (S.overageIncluded) volL *= (1 + S.overagePercent / 100);
            needed = (unit === "kg") ? ((Number(p.density) || 0) > 0 ? volL * (Number(p.density) || 0) : 0) : volL;
            packages = S.exactMode ? needed / packSize : Math.ceil(needed / packSize);
          } else {
            const cov = Number(p.coverSqmPerPack) || 0;
            const covL = Math.max(1, Number(p.coverLayersPerPack) || 1);
            const packNeed = cov > 0 ? (areaSize * (layers / covL) / cov) : 0;
            packages = S.exactMode ? packNeed : Math.ceil(packNeed);
            needed = packages * packSize;
          }
          areaTotal += (priceMode === 'perKg') ? (needed * price) : (packages * price);
        });
        xml += '<Row ss:StyleID="Bold">' + nl;
        xml += `<Cell ss:MergeAcross="17"><Data ss:Type="String">${escapeXML(a.name)} Total</Data></Cell>` + nl;
        xml += `<Cell ss:StyleID="BoldTwoDec"><Data ss:Type="Number">${areaTotal.toFixed(2)}</Data></Cell>` + nl;
        xml += '</Row>' + nl;
      });
      rowIndex++;
      xml += '<Row ss:StyleID="Bold">' + nl;
      xml += '<Cell ss:MergeAcross="17"><Data ss:Type="String">Project Total</Data></Cell>' + nl;
      if (areaTotalRows.length) {
        const refs = areaTotalRows.map(r => `R${r}C`);
        xml += `<Cell ss:StyleID="BoldTwoDec" ss:Formula="=SUM(${refs.join(",")})"><Data ss:Type="Number"></Data></Cell>` + nl;
      } else xml += '<Cell ss:StyleID="BoldTwoDec"><Data ss:Type="Number">0</Data></Cell>' + nl;
      xml += '</Row>' + nl + '</Table>' + nl + '</Worksheet>' + nl + '</Workbook>';
      return xml;
    }

    function exportExcel() {
      downloadBlob(new Blob([generateExcelXML()], { type: "application/vnd.ms-excel" }), "project_estimate.xls");
      log("Exported Excel");
    }

    /* ================== URL STATE LOGIC ================== */
    function generateShortURL() {
      // Map long keys to short keys for URL compression
      const s = state.project.settings;
      const shortData = {
        a: state.project.areas.map(a => ({
          n: a.name,
          m: a.modifier,
          s: a.size,
          p: a.products.map(p => ({
            n: p.name,
            c: p.color,
            l: p.layers,
            t: p.thickness,
            d: p.density,
            ps: p.packSize,
            pu: p.packUnit,
            pr: p.price,
            pm: p.priceMode,
            cm: p.calcMode,
            u: p.usagePerM2,
            cs: p.coverSqmPerPack,
            cl: p.coverLayersPerPack
          }))
        })),
        s: {
          v: s.vatIncluded ? 1 : 0,
          vr: s.vatRate,
          o: s.overageIncluded ? 1 : 0,
          op: s.overagePercent
        }
      };
      const json = JSON.stringify(shortData);
      const b64 = btoa(json);
      const url = window.location.protocol + "//" + window.location.host + window.location.pathname + "?d=" + b64;
      navigator.clipboard.writeText(url).then(() => alert(t("linkCopied"))).catch(e => prompt("Copy Link:", url));
    }

    function loadStateFromURL() {
      const params = new URLSearchParams(window.location.search);
      if (!params.has("d")) return;
      try {
        const json = atob(params.get("d"));
        const short = JSON.parse(json);
        if (short.a) {
          state.project.areas = short.a.map((a, i) => ({
            id: i + 1,
            name: a.n,
            modifier: a.m,
            size: a.s,
            products: (a.p || []).map((p, j) => ({
              id: j + 1,
              name: p.n,
              color: p.c,
              layers: p.l,
              thickness: p.t,
              density: p.d,
              packSize: p.ps,
              packUnit: p.pu,
              price: p.pr,
              priceMode: p.pm,
              calcMode: p.cm,
              usagePerM2: p.u,
              coverSqmPerPack: p.cs,
              coverLayersPerPack: p.cl
            }))
          }));
          state.nextAreaId = state.project.areas.length + 1;
          state.nextProductId = 1000; // safe margin
        }
        if (short.s) {
          state.project.settings.vatIncluded = !!short.s.v;
          state.project.settings.vatRate = short.s.vr;
          state.project.settings.overageIncluded = !!short.s.o;
          state.project.settings.overagePercent = short.s.op;
        }
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
        log("Loaded state from URL");
      } catch (e) {
        console.error(e);
        log("Error loading URL state");
      }
    }

    /* ================== EVENTS ================== */
    btnAddAreaDock.addEventListener("click", () => {
      const id = state.nextAreaId++;
      const nm = (LANG === "sv" ? "Omr√•de " : "Area ") + id;
      const a = { id, name: nm, modifier: state.project.settings.surfaceTypes["Smooth"], size: 0, products: [] };
      state.project.areas.push(a);
      const el = createAreaElement(a);
      areasContainer.appendChild(el);
      log(`Added area "${nm}"`);
      pushStateForUndo(`Added area ${nm}`);
      updateCalculations();
      el.scrollIntoView({ behavior: "smooth", block: "center" });
      topAddDock.style.display = "none";
    });
    undoBtn.addEventListener("click", undo);
    redoBtn.addEventListener("click", redo);
    vatToggle.addEventListener("change", () => {
      state.project.settings.vatIncluded = vatToggle.checked;
      log(`VAT ${vatToggle.checked?"included":"excluded"}`);
      updateCalculations();
    });
    vatPercentInput.addEventListener("change", () => {
      state.project.settings.vatRate = toPosFloat(vatPercentInput.value, 0);
      log(`VAT ${state.project.settings.vatRate}%`);
      updateCalculations();
    });
    overageToggle.addEventListener("change", () => {
      state.project.settings.overageIncluded = overageToggle.checked;
      log(`${overageToggle.checked?"Apply":"Remove"} overage`);
      updateCalculations();
    });
    overagePercentInput.addEventListener("change", () => {
      state.project.settings.overagePercent = toPosFloat(overagePercentInput.value, 0);
      if (state.project.settings.overageIncluded) updateCalculations();
    });
    exactToggle.addEventListener("change", () => {
      state.project.settings.exactMode = exactToggle.checked;
      log(`Exact mode ${state.project.settings.exactMode?"ON":"OFF"}`);
      updateCalculations();
    });
    darkModeToggle.addEventListener("change", () => {
      state.project.settings.darkMode = darkModeToggle.checked;
      document.body.classList.toggle("dark-mode", state.project.settings.darkMode);
    });
    stepModeToggle.addEventListener("change", () => {
      state.project.settings.stepMode = stepModeToggle.checked;
      document.body.classList.toggle("step-on", state.project.settings.stepMode);
      updateCalculations();
    });
    hideDecimalsToggle.addEventListener("change", () => {
      state.project.settings.hideDecimals = hideDecimalsToggle.checked;
      log(`Hide decimals ${hideDecimalsToggle.checked?"ON":"OFF"}`);
      updateCalculations();
    });
    importBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const r = new FileReader();
      r.onload = () => importData(file, r.result);
      r.onerror = () => {
        alert("Failed to read file");
        log("Error reading file");
      };
      r.readAsText(file);
      fileInput.value = "";
    });
    exportJSONBtn.addEventListener("click", exportJSON);
    exportCSVBtn.addEventListener("click", exportCSV);
    exportExcelBtn.addEventListener("click", exportExcel);
    shareLinkBtn.addEventListener("click", generateShortURL);
    printBtn.addEventListener("click", () => {
      window.print();
      log("Print/PDF");
    });
    minimizeLogBtn.addEventListener("click", () => {
      if (!logPanel.classList.contains("minimized")) logPanel.classList.add("minimized");
      else {
        logPanel.classList.remove("minimized");
        logPanel.classList.remove("maximized");
      }
    });
    maximizeLogBtn.addEventListener("click", () => {
      if (logPanel.classList.contains("maximized")) logPanel.classList.remove("maximized");
      else {
        logPanel.classList.remove("minimized");
        logPanel.classList.add("maximized");
      }
    });
    btnScrollSummary.addEventListener("click", () => {
      document.getElementById("infoSummary").scrollIntoView({ behavior: "smooth" });
    });
    langSV.addEventListener("click", () => {
      LANG = "sv";
      state.project.settings.surfaceInfo = SURFACE_INFO.sv;
      langSV.classList.add("active");
      langEN.classList.remove("active");
      applyI18n();
      renderAll();
    });
    langEN.addEventListener("click", () => {
      LANG = "en";
      state.project.settings.surfaceInfo = SURFACE_INFO.en;
      langEN.classList.add("active");
      langSV.classList.remove("active");
      applyI18n();
      renderAll();
    });

    /* ================== INIT ================== */
    // Populate Datalist
    PRELOADED_PRODUCTS.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p.name;
      productSuggestions.appendChild(opt);
    });

    loadTemplates();
    loadStateFromURL(); // Check for URL params
    applyI18n();
    log("App started");
    renderAll();

  })();
  </script>
</body>
</html>
