<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Betongytor ‚Äî Material- & Kostnadsestimator PRO</title>
  <style>
    /* ================== THEME ================== */
    :root{
      --bg:#f4f9ff;
      --fg:#0f172a;
      --muted:#475569;
      --panel:#ffffff;
      --line:#dbe5f0;
      --accent:#2563eb;
      --accent-2:#10b981;
      --danger:#ef4444;
      --shadow:0 10px 24px rgba(2,32,71,.08);
      --rowBg:#ffffff;
      --rowAlt:#f8fbff;
      --rowProd:#f0fbf5;
      --rowProj:#f4f8ff;
      --tooltipBg:#111827;
      --tooltipFg:#f9fafb;
      --grad:linear-gradient(180deg,#f8fbff 0%,#eef6ff 50%,#f7fffb 100%);
    }
    body.dark-mode{
      --bg:#0b0f1a;
      --fg:#e5efff;
      --muted:#9fb0c8;
      --panel:#0f172a;
      --line:#213047;
      --accent:#60a5fa;
      --accent-2:#34d399;
      --danger:#f87171;
      --shadow:0 10px 24px rgba(0,0,0,.45);
      --rowBg:#0b1427;
      --rowAlt:#0c1a33;
      --rowProd:#0b1e19;
      --rowProj:#0b1424;
      --tooltipBg:#0b1220;
      --tooltipFg:#e5efff;
      --grad:linear-gradient(180deg,#0b0f1a 0%,#0b1220 100%);
    }
    html,body{height:100%}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif;
      background:var(--grad); color:var(--fg); margin:0;
      padding-bottom:90px;
    }

    /* ================== TOP BARS ================== */
    .toolbar{
      position:sticky;top:0;z-index:30;
      background:linear-gradient(180deg,var(--panel) 0%,rgba(255,255,255,.65) 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
      padding:10px 12px; display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      border-bottom:1px solid var(--line); box-shadow:0 6px 14px rgba(15,23,42,.06);
    }
    body.dark-mode .toolbar{
      background:linear-gradient(180deg,#0f172a 0%,#0b1220 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
      box-shadow:0 6px 14px rgba(0,0,0,.45);
    }
    .subbar{
      position:sticky;top:60px;z-index:29;
      background:linear-gradient(180deg,var(--panel) 0%,rgba(255,255,255,.9) 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
      padding:8px 12px; border-bottom:1px solid var(--line);
      display:flex; align-items:center;
    }
    body.dark-mode .subbar{
      background:linear-gradient(180deg,#0f172a 0%,#0b1220 100%);
      backdrop-filter:saturate(1.15) blur(6px);
      -webkit-backdrop-filter:saturate(1.15) blur(6px);
    }
    .subbar .left{flex:1; display:flex; gap:8px; align-items:center}
    .subbar .right{display:flex; gap:8px; align-items:center}

    .group{display:flex;align-items:center;gap:8px;background:var(--panel);border:1px solid var(--line);padding:6px 8px;border-radius:12px}
    .btn{
      appearance:none;border:0;border-radius:12px;padding:8px 12px;cursor:pointer;font-weight:700;letter-spacing:.2px;
      box-shadow:var(--shadow);transition:transform .04s ease,filter .14s ease, background .2s ease, color .2s ease;
      background:var(--panel); color:var(--fg); border:1px solid var(--line);
    }
    .btn:active{transform:translateY(1px)}
    .btn-primary{background:var(--accent-2);color:#00140c;border:1px solid transparent}
    .btn-blue{background:var(--accent);color:#ecfeff;border:1px solid transparent}
    .icon-btn{width:42px;height:42px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:20px}
    .flag-btn{font-size:18px;line-height:1;padding:6px 10px;border-radius:10px;border:1px solid var(--line);background:var(--panel);cursor:pointer}
    .flag-btn.active{outline:2px solid var(--accent);}

    .grow{flex:1}
    .toolbar label{font-weight:600}
    .toolbar input[type="number"]{width:74px}

    /* Top "Add area" dock */
    #topAddDock{padding:10px 12px; display:flex; justify-content:flex-start}
    #btnAddAreaDock{min-width:220px}

    /* ================== LAYOUT ================== */
    #areasContainer{padding:12px}
    .area{
      background:var(--panel);border:1px solid var(--line);border-radius:16px;margin:16px 6px;padding:12px 12px 10px;
      box-shadow:var(--shadow); position:relative;
    }
    .area-header{
      display:grid;
      grid-template-columns: 260px 180px 120px 200px 1fr 180px auto;
      gap:10px; align-items:center; margin-bottom:6px
    }
    .mini-caption{grid-column:1/-1; font-size:.75em; color:var(--muted); margin-top:-2px;}
    .unit-wrap{display:flex;align-items:center;gap:6px}
    .unit-wrap input{flex:1;padding:8px 10px;border:1px solid var(--line);border-radius:10px;background:var(--panel);color:var(--fg)}
    .unit-wrap .unit{font-weight:700;color:var(--muted)}
    .del-area{background:var(--panel);color:#991b1b;border:1px solid #fecaca55;border-radius:10px;padding:8px 10px;cursor:pointer; align-self:start}
    .del-area:hover{background:#ffeff157}

    /* Small illustration top-right (50% smaller) */
    .mini-illustration{border:1px solid var(--line);background:var(--panel);border-radius:12px;padding:6px;width:170px;justify-self:end}
    .mini-illustration canvas{width:100%;height:80px;border-radius:8px;background:var(--panel)}

    /* ================== TABLE ================== */
    table.area-table{width:100%;border-collapse:separate;border-spacing:0 5px;margin-bottom:4px}
    thead tr th{font-size:.72em;text-transform:uppercase;letter-spacing:.04em;color:var(--muted);padding:3px 6px}
    table.area-table th,table.area-table td{padding:3px 6px;background:var(--rowBg);border:1px solid var(--line)}
    table.area-table th:first-child,table.area-table td:first-child{border-top-left-radius:9px;border-bottom-left-radius:9px}
    table.area-table th:last-child,table.area-table td:last-child{border-top-right-radius:9px;border-bottom-right-radius:9px}
    table.area-table input,table.area-table select{
      width:100%;box-sizing:border-box;padding:3px 6px;border:1px solid var(--line);border-radius:8px;font:inherit;background:var(--panel);color:var(--fg);
      height:26px; line-height:24px
    }
    table.area-table input:disabled, table.area-table select:disabled {
      background: var(--line);
      color: var(--muted);
      cursor: not-allowed;
    }
    .th-group{background:var(--rowAlt);font-weight:800;text-align:center;border:1px solid var(--line);padding:3px 4px}
    .td-prod{background:var(--rowProd)}
    .td-proj{background:var(--rowProj)}
    .drag-handle{cursor:grab;font-size:16px;user-select:none}
    .product-row{position:relative;background:var(--rowBg)}
    .product-row.dragging{opacity:.6}

    /* overlay actions ONLY on hover */
    .row-actions-overlay{position:absolute; top:-9px; right:6px; display:none; gap:6px; z-index:3}
    .product-row:hover .row-actions-overlay{display:flex}
    .mini{font-size:.76em;padding:3px 6px;border-radius:7px;border:1px solid var(--line);background:var(--panel);cursor:pointer; height:22px}
    .mini.ghost{border-color:var(--line);color:var(--muted)}
    .mini.warn{border-color:#fde68a55;background:#fde68a19;color:#92400e}
    .mini.danger{border-color:#fecaca55;background:#fecaca22;color:#9f1239}

    /* Inline surface info under table - small text row */
    .surface-inline{display:none; margin:6px 2px 0; font-size:.92em; color:var(--muted)}
    .surface-inline.show{display:block}

    /* Footer buttons in area (stacked, same vertical line & size; smaller buttons) */
    .footer-buttons{display:flex; flex-direction:column; gap:6px; margin-top:6px; align-items:flex-start}
    .btn-slim{padding:5px 8px; border-radius:8px; width:auto}

    /* ================== SUMMARY & INFO ================== */
    #infoSummary{margin:14px;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)}
    #infoSummary header{display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--line);padding:10px 12px}
    #infoSummary .body{padding:10px 12px}
    .info-card{border:1px solid var(--line);border-radius:12px;padding:10px;margin:8px 0;background:var(--rowAlt)}
    .product-total{border:1px solid var(--line);border-radius:12px;padding:10px;margin:8px 0;background:var(--rowAlt)}
    .product-total h5{margin:0 0 4px 0}
    .product-total .dim{color:var(--muted)}

    /* ================== STICKY FOOTER TOTAL ================== */
    #footerBar{
      position:fixed; left:0; right:0; bottom:0; z-index:40;
      background:linear-gradient(180deg,var(--panel) 0%, rgba(255,255,255,0.92) 100%);
      border-top:1px solid var(--line); display:flex; align-items:center; gap:10px; padding:10px 12px;
      box-shadow:0 -8px 20px rgba(0,0,0,.07)
    }
    body.dark-mode #footerBar{
      background:linear-gradient(180deg,#0f172a 0%, #0b1220 100%);
      box-shadow:0 -8px 20px rgba(0,0,0,.45)
    }
    #footerBar strong{font-size:1.05em}
    #footerBar .sp{flex:1}
    #footerBar .btn{padding:8px 12px;border-radius:10px}

    /* ================== TOAST & HOVERTIP ================== */
    #infoToast{
      position:fixed;right:16px;bottom:86px;background:var(--tooltipBg);color:var(--tooltipFg);padding:10px 12px;border-radius:999px;
      cursor:pointer;display:none;align-items:center;gap:8px;box-shadow:var(--shadow);z-index:45
    }
    #infoToast .dot{width:8px;height:8px;border-radius:50%;background:#22c55e}
    #hoverTip{
      position:fixed; pointer-events:none; z-index:50; display:none; max-width:320px;
      background:var(--tooltipBg); color:var(--tooltipFg); padding:8px 10px; border-radius:10px; font-size:.9em; box-shadow:var(--shadow)
    }

    /* ================== LOGS ================== */
    #logPanel{position:fixed;bottom:50px;left:0;right:0;background:#0b1220;color:#e5e7eb;font-family:ui-monospace,Consolas,monospace;font-size:.9em;max-height:230px;display:flex;flex-direction:column;border-top:2px solid #1f2937;z-index:35}
    body:not(.dark-mode) #logPanel{background:#0b1220}
    #logHeader{background:#0f172a;padding:6px 8px;font-weight:800;display:flex;align-items:center;gap:8px}
    #logHeader .sp{flex:1}
    #logHeader button{background:#1f2937;color:#fff;border:none;padding:4px 8px;margin-left:5px;cursor:pointer;font-weight:bold;border-radius:8px}
    #logContent{overflow-y:auto;padding:6px}
    #logPanel.minimized{max-height:none;height:auto}
    #logPanel.minimized #logContent{display:none}
    #logPanel.maximized{max-height:65vh}

    /* ================== PRINT ================== */
    @media print{
      .toolbar,.subbar,#topAddDock,#footerBar,#logPanel,#infoToast,#hoverTip{display:none!important}
      .area{border:none;margin:0;page-break-inside:avoid}
      .del-area,.row-actions-overlay,.drag-handle{display:none!important}
    }
  </style>
</head>
<body>
  <!-- ================== MAIN TOOLBAR ================== -->
  <div class="toolbar" id="toolbar">
    <!-- Undo/Redo then Dark/Step -->
    <button id="undo" class="btn icon-btn" disabled title="√Öngra"><span aria-hidden="true">‚Ü∂</span></button>
    <button id="redo" class="btn icon-btn" disabled title="G√∂r om"><span aria-hidden="true">‚Ü∑</span></button>
    <div class="group">
      <label for="darkModeToggle" data-i18n="dark">M√∂rkt l√§ge</label><input type="checkbox" id="darkModeToggle"/>
      <label for="stepModeToggle" data-i18n="step">Steg-f√∂r-steg</label><input type="checkbox" id="stepModeToggle"/>
    </div>

    <div class="group">
      <span data-i18n="vat">Moms</span>
      <label for="vatToggle" data-i18n="include">inkludera</label><input type="checkbox" id="vatToggle"/>
      <input type="number" id="vatPercent" value="25" step="1"/>%
    </div>

    <div class="group">
      <span data-i18n="overage">Spill</span>
      <label for="overageToggle" data-i18n="apply">anv√§nd</label><input type="checkbox" id="overageToggle"/>
      <input type="number" id="overagePercent" value="10" step="1"/>%
    </div>

    <div class="group">
      <label for="exactToggle" data-i18n="exact">Exakt ber√§kning (ingen avrundning)</label>
      <input type="checkbox" id="exactToggle"/>
    </div>

    <div class="group">
      <label for="hideDecimalsToggle" data-i18n="hideDecimals">D√∂lj decimaler</label>
      <input type="checkbox" id="hideDecimalsToggle" checked/>
    </div>

    <div class="grow"></div>

    <!-- Language FAR RIGHT -->
    <div class="group">
      <strong data-i18n="language">Spr√•k</strong>
      <button id="langSV" class="flag-btn active" title="Svenska">üá∏üá™</button>
      <button id="langEN" class="flag-btn" title="English">üá¨üáß</button>
    </div>
  </div>

  <!-- ================== SUBBAR (Import left, Export right) ================== -->
  <div class="subbar" id="subbar">
    <div class="left">
      <button id="importData" class="btn" data-i18n="import">Importera</button>
      <input type="file" id="fileInput" accept=".json,.csv,.xls,.xlsx" style="display:none"/>
    </div>
    <div class="right">
      <button id="exportJSON" class="btn" data-i18n="exportJSON">Export JSON</button>
      <button id="exportCSV" class="btn" data-i18n="exportCSV">Export CSV</button>
      <button id="exportExcel" class="btn" data-i18n="exportExcel">Export Excel</button>
      <button id="shareLink" class="btn btn-blue" data-i18n="shareLink">üîó Share Link</button>
      <button id="printBtn" class="btn" data-i18n="print">Skriv ut / PDF</button>
    </div>
  </div>

  <!-- ================== ADD AREA DOCK (top; hidden after first area) ================== -->
  <div id="topAddDock">
    <button id="btnAddAreaDock" class="btn btn-primary" data-i18n="addArea">+ L√§gg till omr√•de</button>
  </div>

  <!-- ================== AREAS ================== -->
  <div id="areasContainer"></div>

  <!-- ================== SUMMARY & INFO ================== -->
  <section id="infoSummary" style="margin-top:8px">
    <header>
      <strong data-i18n="infoTitle">Info & summeringar</strong>
      <small id="lastInfoTime" style="color:var(--muted)"></small>
    </header>
    <div class="body" id="infoBody">
      <div class="info-card" id="moistureCard">
        <strong>Fukt & fuktighet</strong>
        <p style="margin:.4em 0 .2em 0; color:var(--muted)">
          H√∂g fukthalt i underlag/luft kan √∂ka √•tg√•ngen (absorptionsf√∂rluster) och f√∂rl√§nga torktider. Rekommendation:
          torr och dammfri yta, RF ‚â§ 75‚Äì80% n√§r datablad kr√§ver det, provyta vid tveksamhet. 
          <em>(Informativt ‚Äî p√•verkar inte ber√§kning automatiskt.)</em>
        </p>
      </div>
      <em data-i18n="infoEmpty">Ingen info √§nnu. L√§gg till produkter och ytor.</em>
    </div>
  </section>

  <!-- ================== GLOBAL TEMPLATES (bottom) ================== -->
  <section id="globalProducts" style="margin:14px;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)">
    <header style="display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--line);padding:10px 12px">
      <strong data-i18n="templatesTitle">Globala Produktmallar</strong>
      <div class="template-actions" style="display:flex;gap:8px">
        <button id="addTemplate" class="btn btn-primary" data-i18n="addTemplate">+ L√§gg till mall</button>
        <button id="applyAllTemplates" class="btn" data-i18n="applyAllTemplates">Anv√§nd ALLA p√• ALLA omr√•den</button>
      </div>
    </header>
    <div class="body" id="templatesBody" style="padding:10px 12px"></div>
  </section>

  <!-- ================== STICKY FOOTER TOTAL ================== -->
  <div id="footerBar">
    <strong id="footerTotalLabel">Projektets totalsumma (exkl. moms):</strong>
    <strong id="footerTotalValue">0.00</strong>
    <span class="sp"></span>
    <button class="btn" id="btnScrollSummary">Visa summering</button>
  </div>

  <!-- ================== TOAST & HOVERTIP ================== -->
  <div id="infoToast" title="Visa info"><span class="dot"></span><span data-i18n="toast">Info uppdaterad ‚Äî Visa</span></div>
  <div id="hoverTip"></div>

  <!-- ================== LOGS ================== -->
  <div id="logPanel" class="minimized">
    <div id="logHeader">LOGGAR<span class="sp"></span>
      <button id="minimizeLog">_</button><button id="maximizeLog">&#9723;</button>
    </div>
    <div id="logContent"></div>
  </div>

  <!-- ================== DATALIST FOR SUGGESTIONS ================== -->
  <datalist id="productSuggestions"></datalist>

  <script>
  (() => {
    "use strict";

    /* ================== PRELOADED PRODUCTS ================== */
    const PRELOADED_PRODUCTS = [
      {
        name: "Testproduct 1",
        color: "#ff5733",
        calcMode: "usage",
        usagePerM2: 1.5,
        packSize: 20,
        packUnit: "kg",
        price: 450,
        priceMode: "perPack",
        layers: 1
      },
      {
        name: "Testproduct 2",
        color: "#33ff57",
        calcMode: "thickness",
        thickness: 5,
        density: 1.8,
        packSize: 25,
        packUnit: "kg",
        price: 12,
        priceMode: "perKg",
        layers: 1
      },
      {
        name: "Testproduct 3",
        color: "#3357ff",
        calcMode: "coverage",
        coverSqmPerPack: 12,
        coverLayersPerPack: 1,
        packSize: 5,
        packUnit: "L",
        price: 800,
        priceMode: "perPack",
        layers: 2
      }
    ];

    /* ================== I18N ================== */
    const i18n = {
      sv: {
        addArea: "+ L√§gg till omr√•de",
        addAreaBelow: "+ L√§gg till omr√•de under",
        undoText: "√Öngra",
        redoText: "G√∂r om",
        language: "Spr√•k",
        vat: "Moms",
        include: "inkludera",
        overage: "Spill",
        apply: "anv√§nd",
        exact: "Exakt ber√§kning (ingen avrundning)",
        dark: "M√∂rkt l√§ge",
        step: "Steg-f√∂r-steg",
        import: "Importera",
        exportJSON: "Export JSON",
        exportCSV: "Export CSV",
        exportExcel: "Export Excel",
        print: "Skriv ut / PDF",
        shareLink: "üîó Dela L√§nk",
        templatesTitle: "Globala Produktmallar",
        addTemplate: "+ L√§gg till mall",
        applyAllTemplates: "Anv√§nd ALLA p√• ALLA omr√•den",
        infoTitle: "Info & summeringar",
        infoEmpty: "Ingen info √§nnu. L√§gg till produkter och ytor.",
        toast: "Info uppdaterad ‚Äî Visa",
        areaName: "Omr√•desnamn",
        surface: "Yttyp",
        factor: "Faktor",
        size: "Storlek",
        sq: "m¬≤",
        product: "Produkt",
        calc: "L√§ge",
        usage: "√Ötg√•ng (kg per m¬≤)",
        usageHint: "Vanligen kg/m¬≤ per lager enligt datablad.",
        layers: "Lager",
        thickness: "Tjocklek (mm)",
        density: "Densitet (kg/L)",
        packSize: "F√∂rp. storlek",
        unit: "Enhet",
        priceMode: "Pris-l√§ge",
        perPack: "Pris/f√∂rp",
        perKg: "Pris/kg",
        pricePack: "Pris/f√∂rp",
        priceKg: "Pris/kg",
        needed: "Behov",
        packages: "F√∂rp",
        cost: "Kostnad",
        addProduct: "+ L√§gg till produktlager",
        calcThickness: "Tjocklek",
        calcUsage: "√Ötg√•ng/m¬≤",
        calcCoverage: "T√§ckning/f√∂rp",
        coverSqm: "T√§ckning (m¬≤/f√∂rp)",
        coverLayers: "Lager per f√∂rp",
        prodInfo: "Produktdata",
        projectInfo: "Projekt/Omr√•desdata",
        deleteArea: "Ta bort omr√•de",
        cloneAll: "Klona ‚Üí Alla",
        cloneBelow: "Klona ‚Üì Nedan",
        breakdown: "‚Ñπ Breakdown",
        remove: "Ta bort",
        hoverSurface: "Yta",
        hoverProduct: "Produkt",
        tmplAdded: "Mall tillagd",
        tmplApplyAll: "Mall applicerad p√• alla omr√•den",
        errUnsupported: "Filformatet st√∂ds inte.",
        updated: "Uppdaterad ",
        color: "F√§rg",
        hideDecimals: "D√∂lj decimaler",
        linkCopied: "L√§nk kopierad till urklipp!"
      },
      en: {
        addArea: "+ Add Area",
        addAreaBelow: "+ Add Area Below",
        undoText: "Undo",
        redoText: "Redo",
        language: "Language",
        vat: "VAT",
        include: "include",
        overage: "Overage",
        apply: "apply",
        exact: "Exact calc (no rounding)",
        dark: "Dark mode",
        step: "Step-by-step",
        import: "Import",
        exportJSON: "Export JSON",
        exportCSV: "Export CSV",
        exportExcel: "Export Excel",
        print: "Print / PDF",
        shareLink: "üîó Share Link",
        templatesTitle: "Global Product Templates",
        addTemplate: "+ Add Template",
        applyAllTemplates: "Apply ALL to ALL Areas",
        infoTitle: "Info & summaries",
        infoEmpty: "No info yet. Add products and areas.",
        toast: "Info updated ‚Äî View",
        areaName: "Area name",
        surface: "Surface",
        factor: "Factor",
        size: "Size",
        sq: "m¬≤",
        product: "Product",
        calc: "Mode",
        usage: "Usage (kg per m¬≤)",
        usageHint: "Usually kg/m¬≤ per layer per data sheet.",
        layers: "Layers",
        thickness: "Thickness (mm)",
        density: "Density (kg/L)",
        packSize: "Pack size",
        unit: "Unit",
        priceMode: "Price Mode",
        perPack: "Price/pack",
        perKg: "Price/kg",
        pricePack: "Price/pack",
        priceKg: "Price/kg",
        needed: "Needed",
        packages: "Packages",
        cost: "Cost",
        addProduct: "+ Add Product Layer",
        calcThickness: "Thickness",
        calcUsage: "Usage/m¬≤",
        calcCoverage: "Coverage/pack",
        coverSqm: "Coverage (m¬≤/pack)",
        coverLayers: "Layers per pack",
        prodInfo: "Product info",
        projectInfo: "Project/Area info",
        deleteArea: "Delete Area",
        cloneAll: "Clone ‚Üí All",
        cloneBelow: "Clone ‚Üì Below",
        breakdown: "‚Ñπ Breakdown",
        remove: "Remove",
        hoverSurface: "Surface",
        hoverProduct: "Product",
        tmplAdded: "Template added",
        tmplApplyAll: "Template applied to all areas",
        errUnsupported: "Unsupported file format.",
        updated: "Updated ",
        color: "Color",
        hideDecimals: "Hide decimals",
        linkCopied: "Link copied to clipboard!"
      }
    };

    let LANG = "sv";

    function t(k) {
      return (i18n[LANG] && i18n[LANG][k]) || k;
    }

    function applyI18n() {
      document.querySelectorAll("[data-i18n]").forEach(el => {
        el.textContent = t(el.getAttribute("data-i18n"));
      });
      refreshSummaryLabels();
    }

    /* ================== STATE ================== */
    const SURFACE_INFO = {
      sv: {
        "Smooth": { title: "Sl√§t / Polerad", desc: "St√§ngda porer; t√§t, gl√§ttad yta.", hint: "+0%", prep: "Enkel reng√∂ring; dammfri", typical: "Gl√§ttad/polerad betongplatta" },
        "Light Grind": { title: "L√§tt slipad", desc: "Mikrostruktur √∂ppnas; n√•got h√∂gre absorption.", hint: "+5%", prep: "Avfettning + l√§tt slipning", typical: "Polerad med l√§tt slipning" },
        "Medium Grind": { title: "Medium slipad", desc: "Synlig sand; mikrosprickor m√∂jliga.", hint: "+10%", prep: "Slipning P80‚ÄìP120", typical: "Trafikslitet inomhusgolv" },
        "Rough": { title: "Grov / sopad", desc: "Grov profil; h√∂g absorption.", hint: "+15%", prep: "Slipning + dammsugning; laga flagor", typical: "Utv√§ndig sopad yta" },
        "Porous/Cracked": { title: "Mycket por√∂s / sprucken", desc: "Kapill√§rer och h√•ligheter; mycket h√∂g absorption med sprickor.", hint: "+25%", prep: "Sprickinjektering + primer", typical: "Gammal platta, frostskador" },
        "Custom": { title: "Anpassad", desc: "Anv√§ndardefinierad ytfaktor.", hint: "beroende", prep: "‚Äî", typical: "‚Äî" }
      },
      en: {
        "Smooth": { title: "Smooth / polished", desc: "Closed pores; dense, burnished surface.", hint: "+0%", prep: "Light cleaning; dust-free", typical: "Troweled/Polished slab" },
        "Light Grind": { title: "Lightly ground", desc: "Micro texture opens; slightly higher uptake.", hint: "+5%", prep: "Degrease + light grind", typical: "Polished with light hone" },
        "Medium Grind": { title: "Medium ground", desc: "Visible sand; micro-cracks possible.", hint: "+10%", prep: "Grinding P80‚ÄìP120", typical: "Traffic-worn interior" },
        "Rough": { title: "Rough / broomed", desc: "Coarse profile; high absorption.", hint: "+15%", prep: "Grinding + vacuum; repair spalls", typical: "Exterior broom finish" },
        "Porous/Cracked": { title: "Highly porous / cracked", desc: "Capillaries & voids; very high absorption with cracks.", hint: "+25%", prep: "Crack injection + primer", typical: "Old slab, freeze-thaw damage" },
        "Custom": { title: "Custom", desc: "User-defined surface factor.", hint: "depends", prep: "‚Äî", typical: "‚Äî" }
      }
    };

    const state = {
      project: {
        areas: [],
        settings: {
          vatIncluded: false,
          vatRate: 25,
          overageIncluded: false,
          overagePercent: 10,
          exactMode: false,
          stepMode: false,
          darkMode: false,
          hideDecimals: true,
          surfaceTypes: {
            "Smooth": 1.00,
            "Light Grind": 1.05,
            "Medium Grind": 1.10,
            "Rough": 1.15,
            "Porous/Cracked": 1.25
          },
          surfaceInfo: SURFACE_INFO[LANG]
        }
      },
      undoStack: [],
      redoStack: [],
      nextAreaId: 1,
      nextProductId: 1,
      nextTemplateId: 1,
      lastAddedProductTemplate: null
    };

    /* ================== DOM REFS ================== */
    const areasContainer = document.getElementById("areasContainer");
    const footerTotalLabel = document.getElementById("footerTotalLabel");
    const footerTotalValue = document.getElementById("footerTotalValue");
    const btnAddAreaDock = document.getElementById("btnAddAreaDock");
    const undoBtn = document.getElementById("undo");
    const redoBtn = document.getElementById("redo");
    const vatToggle = document.getElementById("vatToggle");
    const vatPercentInput = document.getElementById("vatPercent");
    const overageToggle = document.getElementById("overageToggle");
    const overagePercentInput = document.getElementById("overagePercent");
    const exactToggle = document.getElementById("exactToggle");
    const darkModeToggle = document.getElementById("darkModeToggle");
    const stepModeToggle = document.getElementById("stepModeToggle");
    const hideDecimalsToggle = document.getElementById("hideDecimalsToggle");
    const importBtn = document.getElementById("importData");
    const fileInput = document.getElementById("fileInput");
    const exportJSONBtn = document.getElementById("exportJSON");
    const exportCSVBtn = document.getElementById("exportCSV");
    const exportExcelBtn = document.getElementById("exportExcel");
    const shareLinkBtn = document.getElementById("shareLink");
    const printBtn = document.getElementById("printBtn");
    const infoBody = document.getElementById("infoBody");
    const infoToast = document.getElementById("infoToast");
    const lastInfoTime = document.getElementById("lastInfoTime");
    const hoverTip = document.getElementById("hoverTip");
    const btnScrollSummary = document.getElementById("btnScrollSummary");
    const logPanel = document.getElementById("logPanel");
    const logContent = document.getElementById("logContent");
    const minimizeLogBtn = document.getElementById("minimizeLog");
    const maximizeLogBtn = document.getElementById("maximizeLog");
    const langSV = document.getElementById("langSV");
    const langEN = document.getElementById("langEN");
    const topAddDock = document.getElementById("topAddDock");
    const productSuggestions = document.getElementById("productSuggestions");

    /* ================== UTIL & LOG ================== */
    function log(msg) {
      const tms = new Date().toLocaleTimeString();
      const p = document.createElement("p");
      p.textContent = `[${tms}] ${msg}`;
      logContent.appendChild(p);
      if (logContent.scrollHeight - logContent.clientHeight - logContent.scrollTop < 5) {
        logContent.scrollTop = logContent.scrollHeight;
      }
      const ud = state.undoStack.at(-1)?.desc || (LANG === "sv" ? "Inget att √•ngra" : "Nothing to undo");
      const rd = state.redoStack.at(-1)?.desc || (LANG === "sv" ? "Inget att g√∂ra om" : "Nothing to redo");
      undoBtn.title = (LANG === "sv" ? "√Öngra: " : "Undo: ") + ud;
      redoBtn.title = (LANG === "sv" ? "G√∂r om: " : "Redo: ") + rd;
    }

    function pushStateForUndo(desc) {
      const snap = JSON.parse(JSON.stringify(state.project));
      state.undoStack.push({ data: snap, desc });
      state.redoStack.length = 0;
      undoBtn.disabled = state.undoStack.length === 0;
      redoBtn.disabled = true;
      undoBtn.title = (LANG === "sv" ? "√Öngra: " : "Undo: ") + desc;
      redoBtn.title = (LANG === "sv" ? "G√∂r om: " : "Redo: ");
    }

    function undo() {
      if (!state.undoStack.length) return;
      const last = state.undoStack.pop();
      const desc = last.desc;
      state.redoStack.push({ data: JSON.parse(JSON.stringify(state.project)), desc });
      state.project = last.data;
      renderAll();
      log(`Undo: ${desc}`);
      undoBtn.disabled = state.undoStack.length === 0;
      redoBtn.disabled = state.redoStack.length === 0;
    }

    function redo() {
      if (!state.redoStack.length) return;
      const last = state.redoStack.pop();
      const desc = last.desc;
      state.undoStack.push({ data: JSON.parse(JSON.stringify(state.project)), desc });
      state.project = last.data;
      renderAll();
      log(`Redo: ${desc}`);
      undoBtn.disabled = state.undoStack.length === 0;
      redoBtn.disabled = state.redoStack.length === 0;
    }

    function toPosFloat(v, def) {
      const n = parseFloat(v);
      return (isNaN(n) || n < 0) ? def : n;
    }

    function fmt(n) {
      if (!isFinite(n)) return "0";
      if (state.project.settings.hideDecimals) return n.toFixed(0);
      if (Math.abs(n) >= 1000) return n.toFixed(0);
      if (Math.abs(n) >= 10) return n.toFixed(1);
      return n.toFixed(2);
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function formatCSVValue(v) {
      const s = String(v);
      return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
    }

    function escapeXML(s) {
      if (s == null) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    const showInfoToast = (() => {
      let hide = null;
      return () => {
        infoToast.style.display = "flex";
        if (hide) clearTimeout(hide);
        hide = setTimeout(() => infoToast.style.display = "none", 3500);
      };
    })();

    /* ================== SURFACE HELPERS ================== */
    function reverseFindTypeByFactor(f) {
      const m = Object.entries(state.project.settings.surfaceTypes).find(([_, v]) => Math.abs(v - f) < 1e-6);
      return m ? m[0] : null;
    }

    function surfaceExpl(area) {
      const k = reverseFindTypeByFactor(area.modifier) || "Custom";
      const meta = state.project.settings.surfaceInfo[k] || state.project.settings.surfaceInfo["Custom"];
      return {
        type: k,
        title: meta.title,
        desc: meta.desc,
        hint: meta.hint,
        prep: meta.prep,
        typical: meta.typical,
        factor: area.modifier.toFixed(2)
      };
    }

    /* ================== CANVAS ILLUSTRATION ================== */
    function baseConcreteColor(area) {
      const f = area.modifier;
      const l = 90 - Math.min(28, (f - 1) * 65);
      return `hsl(215 14% ${l}%)`;
    }

    function layerColor(p) {
      return p.color || (() => {
        let h = 0;
        const s = (p.name || "Layer");
        for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
        return `hsl(${h % 360} 70% 55%)`;
      })();
    }

    function drawAreaIllustration(canvas, area, highlightId = -1) {
      const ctx = canvas.getContext("2d");
      const W = canvas.width = canvas.clientWidth;
      const H = canvas.height = canvas.clientHeight;
      ctx.clearRect(0, 0, W, H);

      const baseX = W * 0.6;
      const depthX = W * 0.3;
      const depthY = W * 0.15;
      const slabHeightPx = 10;
      const layerHeightPx = 4;
      const marginLeft = 10;
      const marginBottom = 3;
      const slabBottomY = H - marginBottom;
      const originX = depthX + marginLeft;
      const originY = slabBottomY - slabHeightPx;

      const slabFrontLeft = { x: originX, y: originY };
      const slabFrontRight = { x: originX + baseX, y: originY };
      const slabBackLeft = { x: originX - depthX, y: originY - depthY };
      const slabBackRight = { x: originX + baseX - depthX, y: originY - depthY };
      const slabBottomFrontRight = { x: slabFrontRight.x, y: slabFrontRight.y + slabHeightPx };
      const slabBottomBackRight = { x: slabBackRight.x, y: slabBackRight.y + slabHeightPx };

      const sidePolys = [];
      let topPoly = null;

      sidePolys.push({
        id: 0,
        points: [{ ...slabBackRight }, { ...slabFrontRight }, { ...slabBottomFrontRight }, { ...slabBottomBackRight }],
        color: baseConcreteColor(area)
      });

      let curFrontLeft = slabFrontLeft;
      let curFrontRight = slabFrontRight;
      let curBackLeft = slabBackLeft;
      let curBackRight = slabBackRight;

      area.products.forEach(p => {
        const heightPx = (p.layers ? parseInt(p.layers) : 1) * layerHeightPx;
        const bottomFR = curFrontRight;
        const bottomBR = curBackRight;
        const newFrontLeft = { x: curFrontLeft.x, y: curFrontLeft.y - heightPx };
        const newFrontRight = { x: curFrontRight.x, y: curFrontRight.y - heightPx };
        const newBackLeft = { x: curBackLeft.x, y: curBackLeft.y - heightPx };
        const newBackRight = { x: curBackRight.x, y: curBackRight.y - heightPx };

        sidePolys.push({
          id: p.id,
          points: [{ ...newBackRight }, { ...newFrontRight }, { ...bottomFR }, { ...bottomBR }],
          color: layerColor(p)
        });

        curFrontLeft = newFrontLeft;
        curFrontRight = newFrontRight;
        curBackLeft = newBackLeft;
        curBackRight = newBackRight;
      });

      if (area.products.length > 0) {
        const topProduct = area.products[area.products.length - 1];
        topPoly = {
          id: topProduct.id,
          points: [{ ...curFrontLeft }, { ...curFrontRight }, { ...curBackRight }, { ...curBackLeft }],
          color: layerColor(topProduct)
        };
      } else {
        topPoly = {
          id: 0,
          points: [{ ...curFrontLeft }, { ...curFrontRight }, { ...curBackRight }, { ...curBackLeft }],
          color: baseConcreteColor(area)
        };
      }

      canvas._sidePolys = sidePolys;
      canvas._topPoly = topPoly;

      sidePolys.forEach(poly => {
        ctx.beginPath();
        const pts = poly.points;
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i].x, pts[i].y);
        }
        ctx.closePath();
        if (highlightId !== -1 && ((poly.id === 0 && highlightId === 0) || (poly.id > 0 && poly.id === highlightId))) {
          ctx.save();
          ctx.fillStyle = poly.color;
          ctx.filter = "brightness(1.25)";
          ctx.fill();
          ctx.restore();
        } else {
          ctx.fillStyle = poly.color;
          ctx.fill();
        }
      });

      ctx.beginPath();
      const tp = topPoly.points;
      ctx.moveTo(tp[0].x, tp[0].y);
      for (let i = 1; i < tp.length; i++) {
        ctx.lineTo(tp[i].x, tp[i].y);
      }
      ctx.closePath();
      if (highlightId !== -1 && ((topPoly.id === 0 && highlightId === 0) || (topPoly.id > 0 && topPoly.id === highlightId))) {
        ctx.save();
        ctx.fillStyle = topPoly.color;
        ctx.filter = "brightness(1.25)";
        ctx.fill();
        ctx.restore();
      } else {
        ctx.fillStyle = topPoly.color;
        ctx.fill();
      }

      ctx.strokeStyle = "rgba(0,0,0,0.3)";
      ctx.lineWidth = 1;
      for (let i = 0; i < sidePolys.length - 1; i++) {
        const pts = sidePolys[i].points;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        ctx.lineTo(pts[1].x, pts[1].y);
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.moveTo(tp[0].x, tp[0].y);
      for (let i = 1; i < tp.length; i++) {
        ctx.lineTo(tp[i].x, tp[i].y);
      }
      ctx.closePath();
      ctx.stroke();

      const frontRightBase = { x: slabBottomFrontRight.x, y: slabBottomFrontRight.y };
      const frontRightTop = { x: curFrontRight.x, y: curFrontRight.y };
      ctx.beginPath();
      ctx.moveTo(frontRightBase.x, frontRightBase.y);
      ctx.lineTo(frontRightTop.x, frontRightTop.y);
      ctx.stroke();

      const backRightBase = { x: slabBottomBackRight.x, y: slabBottomBackRight.y };
      const backRightTop = { x: curBackRight.x, y: curBackRight.y };
      ctx.beginPath();
      ctx.moveTo(backRightBase.x, backRightBase.y);
      ctx.lineTo(backRightTop.x, backRightTop.y);
      ctx.stroke();
    }

    function attachCanvasInteractions(canvas, area, inlineRow) {
      const tip = hoverTip;
      const show = (html, x, y) => {
        tip.innerHTML = html;
        tip.style.display = "block";
        const pad = 10;
        tip.style.left = (x + pad) + "px";
        tip.style.top = (y + pad) + "px";
      };
      const hide = () => {
        tip.style.display = "none";
      };
      const showInline = (html) => {
        inlineRow.innerHTML = html;
        inlineRow.classList.add("show");
      };
      const hideInline = () => {
        inlineRow.classList.remove("show");
        inlineRow.innerHTML = "";
      };

      canvas.addEventListener("mousemove", (e) => {
        const r = canvas.getBoundingClientRect();
        const x = e.clientX - r.left;
        const y = e.clientY - r.top;
        let highlightId = -1;
        let hoverProduct = null;
        let onSlab = false;

        const topPoly = canvas._topPoly;
        const pointInPoly = (px, py, polyPts) => {
          let inside = false;
          for (let i = 0, j = polyPts.length - 1; i < polyPts.length; j = i++) {
            const xi = polyPts[i].x, yi = polyPts[i].y;
            const xj = polyPts[j].x, yj = polyPts[j].y;
            const intersect = ((yi > py) != (yj > py)) && (px <= (xj - xi) * (py - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
          }
          return inside;
        };

        if (topPoly && pointInPoly(x, y, topPoly.points)) {
          highlightId = topPoly.id;
          if (highlightId === 0) {
            onSlab = true;
          } else {
            hoverProduct = area.products.find(p => p.id === highlightId) || null;
          }
        } else {
          const sidePolys = canvas._sidePolys || [];
          for (let poly of sidePolys) {
            if (pointInPoly(x, y, poly.points)) {
              highlightId = poly.id;
              if (highlightId === 0) {
                onSlab = true;
              } else {
                hoverProduct = area.products.find(p => p.id === highlightId) || null;
              }
              break;
            }
          }
        }

        drawAreaIllustration(canvas, area, highlightId);

        if (hoverProduct) {
          const p = hoverProduct;
          const html = `<div><strong>${t("hoverProduct")}:</strong> ${p.name||"-"}</div><div>‚Ä¢ ${t("layers")}: ${p.layers||1} ‚Ä¢ ${t("thickness")}: ${p.thickness||0} mm</div><div>‚Ä¢ ${t("unit")}: ${p.packUnit||"kg"} ‚Ä¢ ${t("packSize")}: ${p.packSize||0}</div><div>‚Ä¢ ${(p.priceMode==='perKg')?t("priceKg"):t("pricePack")}: ${p.price||0}</div>`;
          show(html, e.clientX, e.clientY);
          hideInline();
        } else if (onSlab) {
          const meta = surfaceExpl(area);
          const html = `<strong>${t("hoverSurface")}:</strong> ${meta.title} (√ó${meta.factor}) ‚Äî ${meta.hint}. ${meta.desc}`;
          show(html, e.clientX, e.clientY);
          showInline(html);
        } else {
          hide();
          hideInline();
        }
      });

      canvas.addEventListener("mouseleave", () => {
        drawAreaIllustration(canvas, area, -1);
        hoverTip.style.display = "none";
        hideInline();
      });
    }

    /* ================== EL HELPER ================== */
    function el(tag, attrs = {}, txt) {
      const e = document.createElement(tag);
      Object.entries(attrs).forEach(([k, v]) => {
        if (k === "class") e.className = v;
        else if (k === "style") e.setAttribute("style", v);
        else e.setAttribute(k, v);
      });
      if (txt != null) e.textContent = txt;
      return e;
    }

    function cloneProductData(prod) {
      return JSON.parse(JSON.stringify({
        name: prod.name || "",
        color: prod.color || null,
        layers: prod.layers || 1,
        thickness: prod.thickness || 0,
        density: (prod.density === null ? null : prod.density || 0),
        packSize: prod.packSize || 1,
        packUnit: prod.packUnit || "kg",
        price: prod.price || 0,
        priceMode: prod.priceMode || "perPack",
        calcMode: prod.calcMode || "thickness",
        usagePerM2: prod.usagePerM2 || 0,
        coverSqmPerPack: prod.coverSqmPerPack || 0,
        coverLayersPerPack: prod.coverLayersPerPack || 1
      }));
    }

    /* ================== AREA UI ================== */
    function createAreaElement(area) {
      const wrap = el("div", { class: "area", "data-area-id": area.id });
      const header = el("div", { class: "area-header" });

      const nameI = el("input", { type: "text", value: area.name, placeholder: t("areaName") });
      nameI.addEventListener("change", () => {
        const old = area.name;
        area.name = nameI.value;
        log(`Renamed area "${old}" ‚Üí "${area.name}"`);
      });
      header.appendChild(nameI);

      const surfaceSel = el("select", { title: t("surface") });
      Object.keys(state.project.settings.surfaceTypes).concat(["Custom"]).forEach(n => {
        const o = el("option", { value: n });
        const surfInfo = state.project.settings.surfaceInfo[n];
        o.textContent = surfInfo ? surfInfo.title : n;
        surfaceSel.appendChild(o);
      });
      const matched = reverseFindTypeByFactor(area.modifier) || "Custom";
      surfaceSel.value = matched;
      header.appendChild(surfaceSel);

      const modI = el("input", { type: "number", step: "0.01", value: area.modifier });
      modI.disabled = (matched !== "Custom");
      header.appendChild(modI);

      const sizeWrap = el("div", { class: "unit-wrap" });
      const sizeI = el("input", { type: "number", min: "0", step: "0.1", value: area.size || 0, placeholder: t("size") });
      const unit = el("div", { class: "unit" }, t("sq"));
      sizeWrap.appendChild(sizeI);
      sizeWrap.appendChild(unit);
      header.appendChild(sizeWrap);

      const miniCap = el("div", { class: "mini-caption" }, `${t("prodInfo")} / ${t("projectInfo")}`);
      header.appendChild(miniCap);

      const mini = el("div", { class: "mini-illustration" });
      const canvas = document.createElement("canvas");
      mini.appendChild(canvas);
      header.appendChild(mini);

      const del = el("button", { class: "del-area", title: t("deleteArea") }, t("deleteArea"));
      del.addEventListener("click", () => removeArea(wrap));
      header.appendChild(del);

      wrap.appendChild(header);

      const table = el("table", { class: "area-table", "data-area-id": area.id });
      const thead = el("thead");
      const grp = el("tr");
      grp.appendChild(el("th", { class: "th-group", colspan: "11" }, t("prodInfo")));
      grp.appendChild(el("th", { class: "th-group", colspan: "5" }, t("projectInfo")));
      thead.appendChild(grp);

      const head = el("tr");
      ["", t("product"), t("color"), t("calc"), t("usage"), t("density"), t("packSize"), t("unit"), t("priceMode"), t("pricePack"), t("coverSqm"), t("coverLayers"),
        t("layers"), t("thickness"), t("needed"), t("packages"), t("cost")
      ].forEach(h => head.appendChild(el("th", {}, h)));
      thead.appendChild(head);
      table.appendChild(thead);

      const tbody = el("tbody");
      tbody.setAttribute("data-area-id", area.id);
      area.products.forEach((p) => tbody.appendChild(buildProductRow(area, p)));
      table.appendChild(tbody);

      const inlineInfo = el("div", { class: "surface-inline", "data-bind": "inlineSurface" });
      wrap.appendChild(table);
      wrap.appendChild(inlineInfo);

      const btnWrap = el("div", { class: "footer-buttons" });
      const addProdBtn = el("button", { class: "btn btn-primary btn-slim" }, t("addProduct"));
      addProdBtn.addEventListener("click", () => {
        const firstAdd = area.products.length === 0 && state.lastAddedProductTemplate;
        const frag = addProduct(area, tbody);
        if (firstAdd) {
          if (confirm(`Klona senaste produkt "${state.lastAddedProductTemplate.name}" till detta omr√•de?`)) {
            applyProductDataToRow(area, frag, state.lastAddedProductTemplate);
            log(`Cloned last product template to "${area.name}"`);
            updateCalculations(true);
          }
        }
      });
      btnWrap.appendChild(addProdBtn);

      const addAreaAfter = el("button", { class: "btn btn-primary btn-slim" }, t("addArea"));
      addAreaAfter.addEventListener("click", () => insertAreaAfter(area.id));
      btnWrap.appendChild(addAreaAfter);
      wrap.appendChild(btnWrap);

      function updateAreaInfoboxAndCanvas(showInline = false) {
        const meta = surfaceExpl(area);
        drawAreaIllustration(canvas, area);
        attachCanvasInteractions(canvas, area, inlineInfo);
        if (showInline) {
          inlineInfo.innerHTML = `<strong>${t("hoverSurface")}:</strong> ${meta.title} (√ó${meta.factor}) ‚Äî ${meta.hint}. ${meta.desc}`;
          inlineInfo.classList.add("show");
        }
      }
      updateAreaInfoboxAndCanvas();

      surfaceSel.addEventListener("change", () => {
        if (surfaceSel.value === "Custom") {
          modI.disabled = false;
        } else {
          area.modifier = state.project.settings.surfaceTypes[surfaceSel.value];
          modI.value = area.modifier;
          modI.disabled = true;
          log(`Surface "${area.name}" ‚Üí ${surfaceSel.value} (x${area.modifier})`);
          updateCalculations(true);
        }
        updateAreaInfoboxAndCanvas(true);
      });
      surfaceSel.addEventListener("mouseenter", () => updateAreaInfoboxAndCanvas(true));
      surfaceSel.addEventListener("mouseleave", () => {
        inlineInfo.classList.remove("show");
        inlineInfo.innerHTML = "";
      });

      modI.addEventListener("change", () => {
        const v = toPosFloat(modI.value, 1.0);
        modI.value = v;
        area.modifier = v;
        surfaceSel.value = reverseFindTypeByFactor(v) || "Custom";
        if (surfaceSel.value !== "Custom") {
          modI.disabled = true;
        }
        log(`Surface factor "${area.name}" ‚Üí ${v}`);
        updateCalculations(true);
        updateAreaInfoboxAndCanvas(true);
      });

      const sizeIChange = () => {
        const v = toPosFloat(sizeI.value, 0);
        sizeI.value = v;
        area.size = v;
        log(`Area size "${area.name}" ‚Üí ${v} m¬≤`);
        updateCalculations();
      };
      sizeI.addEventListener("change", sizeIChange);

      enableDragSort(tbody, area);

      return wrap;
    }

    function buildProductRow(area, product) {
      if (!product.calcMode) product.calcMode = "thickness";
      if (product.usagePerM2 == null) product.usagePerM2 = 0;
      if (product.coverSqmPerPack == null) product.coverSqmPerPack = 0;
      if (product.coverLayersPerPack == null || product.coverLayersPerPack <= 0) product.coverLayersPerPack = 1;
      if (!product.priceMode) product.priceMode = "perPack";

      const tr = el("tr", { class: "product-row", "data-product-id": product.id, draggable: "true" });
      const td = (child, cls) => {
        const c = document.createElement("td");
        if (cls) c.className = cls;
        c.appendChild(child);
        return c;
      };

      const drag = el("span", { class: "drag-handle", title: "Drag to reorder" }, "‚ò∞");
      tr.appendChild(td(drag, "td-prod"));

      // Product Name with Datalist
      const nameI = el("input", { type: "text", value: product.name, placeholder: t("product"), list: "productSuggestions" });
      nameI.addEventListener("change", () => {
        product.name = nameI.value;
        state.lastAddedProductTemplate = cloneProductData(product);
        log(`Renamed product ${product.id} in "${area.name}" ‚Üí "${product.name}"`);
      });

      // Auto-fill logic
      nameI.addEventListener("input", (e) => {
        const val = e.target.value;
        const match = PRELOADED_PRODUCTS.find(p => p.name === val);
        if (match) {
          // Update product data
          Object.assign(product, cloneProductData(match));
          product.id = parseInt(tr.getAttribute("data-product-id")); // Restore ID
          // Update UI fields
          colorI.value = product.color || "#6cb2ff";
          mode.value = product.calcMode;
          usageI.value = product.usagePerM2;
          densI.value = product.density || "";
          packI.value = product.packSize;
          unitSel.value = product.packUnit;
          priceModeSel.value = product.priceMode;
          priceI.value = product.price;
          coverSqmI.value = product.coverSqmPerPack;
          coverLayersI.value = product.coverLayersPerPack;
          layersI.value = product.layers;
          thickI.value = product.thickness;
          // Trigger updates
          bindModeUI();
          updateCalculations(true);
          const canv = document.querySelector(`.area[data-area-id="${area.id}"] .mini-illustration canvas`);
          if (canv) drawAreaIllustration(canv, area);
        }
      });
      tr.appendChild(td(nameI, "td-prod"));

      const colorI = el("input", { type: "color", value: product.color || "#6cb2ff", title: t("color") });
      colorI.addEventListener("input", () => {
        product.color = colorI.value;
        const canv = document.querySelector(`.area[data-area-id="${area.id}"] .mini-illustration canvas`);
        if (canv) drawAreaIllustration(canv, area);
      });
      tr.appendChild(td(colorI, "td-prod"));

      const mode = el("select");
      [
        ["thickness", t("calcThickness")],
        ["usage", t("calcUsage")],
        ["coverage", t("calcCoverage")]
      ].forEach(([v, l]) => {
        const o = el("option", { value: v });
        o.textContent = l;
        mode.appendChild(o);
      });
      mode.value = product.calcMode;
      tr.appendChild(td(mode, "td-prod"));

      const usageI = el("input", { type: "number", min: "0", step: "0.001", value: product.usagePerM2 || 0, title: t("usageHint") });
      tr.appendChild(td(usageI, "td-prod"));

      const densI = el("input", { type: "number", min: "0", step: "0.01", value: (product.density ?? "") });
      densI.placeholder = t("density");
      tr.appendChild(td(densI, "td-prod"));

      const packI = el("input", { type: "number", min: "0.0001", step: "0.1", value: product.packSize || 1 });
      packI.addEventListener("change", () => {
        product.packSize = Math.max(0.0001, parseFloat(packI.value) || 1);
        packI.value = product.packSize;
        log(`Pack size "${product.name}" ‚Üí ${product.packSize} ${product.packUnit}`);
        updateCalculations();
      });
      tr.appendChild(td(packI, "td-prod"));

      const unitSel = el("select");
      ["kg", "L"].forEach(u => {
        const o = el("option", { value: u });
        o.textContent = u;
        unitSel.appendChild(o);
      });
      unitSel.value = product.packUnit || "kg";
      tr.appendChild(td(unitSel, "td-prod"));

      const priceModeSel = el("select");
      [
        ["perPack", t("perPack")],
        ["perKg", t("perKg")]
      ].forEach(([v, l]) => {
        const o = el("option", { value: v });
        o.textContent = l;
        priceModeSel.appendChild(o);
      });
      priceModeSel.value = product.priceMode;
      tr.appendChild(td(priceModeSel, "td-prod"));

      const priceI = el("input", { type: "number", min: "0", step: "0.01", value: product.price || 0, placeholder: t("pricePack") });
      tr.appendChild(td(priceI, "td-prod"));

      const coverSqmI = el("input", { type: "number", min: "0", step: "0.1", value: product.coverSqmPerPack || 0 });
      tr.appendChild(td(coverSqmI, "td-prod"));

      const coverLayersI = el("input", { type: "number", min: "1", step: "1", value: product.coverLayersPerPack || 1 });
      tr.appendChild(td(coverLayersI, "td-prod"));

      const layersI = el("input", { type: "number", min: "1", step: "1", value: product.layers || 1 });
      layersI.addEventListener("change", () => {
        product.layers = Math.max(1, parseInt(layersI.value) || 1);
        layersI.value = product.layers;
        log(`Layers "${product.name}" ‚Üí ${product.layers}`);
        updateCalculations();
      });
      tr.appendChild(td(layersI, "td-proj"));

      const thickI = el("input", { type: "number", min: "0", step: "0.1", value: product.thickness || 0 });
      thickI.addEventListener("change", () => {
        product.thickness = toPosFloat(thickI.value, 0);
        thickI.value = product.thickness;
        log(`Thickness "${product.name}" ‚Üí ${product.thickness} mm`);
        updateCalculations();
      });
      tr.appendChild(td(thickI, "td-proj"));

      const needSpan = el("span", { class: "neededQty" }, "0");
      tr.appendChild(td(needSpan, "td-proj"));
      const pkgSpan = el("span", { class: "packageCount" }, "0");
      tr.appendChild(td(pkgSpan, "td-proj"));
      const costSpan = el("span", { class: "cost" }, "0");
      tr.appendChild(td(costSpan, "td-proj"));

      const overlay = el("div", { class: "row-actions-overlay" });
      const cloneAll = el("button", { class: "mini ghost", "data-i18n": "cloneAll" }, t("cloneAll"));
      const cloneBelow = el("button", { class: "mini ghost", "data-i18n": "cloneBelow" }, t("cloneBelow"));
      const infoBtn = el("button", { class: "mini warn", "data-i18n": "breakdown" }, t("breakdown"));
      const delBtn = el("button", { class: "mini danger", "data-i18n": "remove" }, t("remove"));
      overlay.appendChild(cloneAll);
      overlay.appendChild(cloneBelow);
      overlay.appendChild(infoBtn);
      overlay.appendChild(delBtn);
      tr.appendChild(overlay);

      const br = document.createElement("tr");
      br.className = "breakdown";
      const brtd = document.createElement("td");
      brtd.colSpan = 16;
      br.appendChild(brtd);
      const brbox = el("div", { class: "breakdown" });
      brtd.appendChild(brbox);

      function bindModeUI() {
        const M = product.calcMode;
        const isUsage = (M === "usage");
        const isThick = (M === "thickness");
        const isCover = (M === "coverage");

        usageI.disabled = !isUsage;
        usageI.title = (!isUsage ? (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="thickness"?"calcThickness":"calcCoverage")}"` : `Not used in "${t(M==="thickness"?"calcThickness":"calcCoverage")}" mode`) : "");

        thickI.disabled = !isThick;
        thickI.title = (!isThick ? (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="usage"?"calcUsage":"calcCoverage")}"` : `Not used in "${t(M==="usage"?"calcUsage":"calcCoverage")}" mode`) : "");

        densI.disabled = (M !== "thickness") || (unitSel.value === "L");
        if (densI.disabled) {
          if (M === "thickness" && unitSel.value === "L") {
            densI.title = LANG === "sv" ? "Ej till√§mplig f√∂r volymbaserad ber√§kning" : "Not used for volume-based calculation";
          } else {
            densI.title = (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="usage"?"calcUsage":"calcCoverage")}"` : `Not used in "${t(M==="usage"?"calcUsage":"calcCoverage")}" mode`);
          }
        } else {
          densI.title = "";
        }

        coverSqmI.disabled = !isCover;
        coverSqmI.title = (!isCover ? (LANG === "sv" ? `Anv√§nds ej i l√§ge "${t(M==="thickness"?"calcThickness":"calcUsage")}"` : `Not used in "${t(M==="thickness"?"calcThickness":"calcUsage")}" mode`) : "");
        coverLayersI.disabled = !isCover;
        coverLayersI.title = coverSqmI.title;
      }
      bindModeUI();

      const applyCalc = () => updateCalculations();
      unitSel.addEventListener("change", () => {
        product.packUnit = unitSel.value;
        bindModeUI();
        log(`Unit "${product.name}" ‚Üí ${product.packUnit}`);
        applyCalc();
      });
      mode.addEventListener("change", () => {
        product.calcMode = mode.value;
        bindModeUI();
        log(`Mode "${product.name}" ‚Üí ${product.calcMode}`);
        updateCalculations(true);
      });
      usageI.addEventListener("change", () => {
        product.usagePerM2 = toPosFloat(usageI.value, 0);
        usageI.value = product.usagePerM2;
        state.lastAddedProductTemplate = cloneProductData(product);
        applyCalc();
      });
      densI.addEventListener("change", () => {
        const v = toPosFloat(densI.value, 0);
        product.density = (densI.value === "" ? null : v);
        applyCalc();
      });
      coverSqmI.addEventListener("change", () => {
        product.coverSqmPerPack = toPosFloat(coverSqmI.value, 0);
        applyCalc();
      });
      coverLayersI.addEventListener("change", () => {
        product.coverLayersPerPack = Math.max(1, parseInt(coverLayersI.value) || 1);
        coverLayersI.value = product.coverLayersPerPack;
        applyCalc();
      });
      priceModeSel.addEventListener("change", () => {
        product.priceMode = priceModeSel.value;
        priceI.placeholder = (product.priceMode === 'perKg') ? t("priceKg") : t("pricePack");
        applyCalc();
      });
      priceI.addEventListener("change", () => {
        product.price = toPosFloat(priceI.value, 0);
        priceI.value = product.price.toFixed(2);
        log(`Price "${product.name}" ‚Üí ${product.price} (${product.priceMode})`);
        applyCalc();
      });
      delBtn.addEventListener("click", () => removeProduct(area, product.id));
      cloneAll.addEventListener("click", () => {
        pushStateForUndo(`Clone "${product.name}" to all areas`);
        state.project.areas.forEach(a => {
          if (a.id !== area.id) {
            const c = cloneProductData(product);
            c.id = state.nextProductId++;
            a.products.push(c);
          }
        });
        log(`Cloned "${product.name}" to all areas`);
        renderAll();
      });
      cloneBelow.addEventListener("click", () => {
        pushStateForUndo(`Clone "${product.name}" to areas below`);
        const idxA = state.project.areas.findIndex(a => a.id === area.id);
        state.project.areas.slice(idxA + 1).forEach(a => {
          const c = cloneProductData(product);
          c.id = state.nextProductId++;
          a.products.push(c);
        });
        log(`Cloned "${product.name}" to areas below`);
        renderAll();
      });
      infoBtn.addEventListener("click", () => {
        state.project.settings.stepMode = !state.project.settings.stepMode;
        stepModeToggle.checked = state.project.settings.stepMode;
        document.body.classList.toggle("step-on", state.project.settings.stepMode);
        updateCalculations(true);
      });

      const frag = document.createDocumentFragment();
      frag.appendChild(tr);
      frag.appendChild(br);
      return frag;
    }

    function addProduct(area, tbody) {
      const p = {
        id: state.nextProductId++,
        name: "",
        color: null,
        layers: 1,
        thickness: 0,
        density: null,
        packSize: 1,
        packUnit: "kg",
        price: 0,
        priceMode: "perPack",
        calcMode: "thickness",
        usagePerM2: 0,
        coverSqmPerPack: 0,
        coverLayersPerPack: 1
      };
      area.products.push(p);
      const frag = buildProductRow(area, p);
      tbody.appendChild(frag);
      log(`Added product in "${area.name}" (ID ${p.id})`);
      pushStateForUndo(`Added product in area ${area.name}`);
      updateCalculations();
      return frag;
    }

    function applyProductDataToRow(area, frag, data) {
      const prod = area.products[area.products.length - 1];
      Object.assign(prod, cloneProductData(data));
      const areaEl = areasContainer.querySelector(`.area[data-area-id="${area.id}"]`);
      if (areaEl) {
        areaEl.replaceWith(createAreaElement(area));
      }
    }

    function insertAreaAfter(areaId) {
      const idx = state.project.areas.findIndex(a => a.id === areaId);
      const id = state.nextAreaId++;
      const nm = (LANG === "sv" ? "Omr√•de " : "Area ") + id;
      const a = { id, name: nm, modifier: state.project.settings.surfaceTypes["Smooth"], size: 0, products: [] };
      pushStateForUndo(`Insert area after ${areaId}`);
      state.project.areas.splice(idx + 1, 0, a);
      renderAll();
      log(`Added area "${nm}"`);
    }

    function removeArea(areaElem) {
      const id = parseInt(areaElem.dataset.areaId);
      const idx = state.project.areas.findIndex(a => a.id === id);
      if (idx === -1) return;
      const nm = state.project.areas[idx].name || `Area ${id}`;
      pushStateForUndo(`Removed area ${nm}`);
      state.project.areas.splice(idx, 1);
      areaElem.remove();
      log(`Removed area "${nm}"`);
      updateCalculations(true);
      if (state.project.areas.length === 0) {
        topAddDock.style.display = "flex";
      }
    }

    function removeProduct(area, prodId) {
      const i = area.products.findIndex(p => p.id === prodId);
      if (i === -1) return;
      const nm = area.products[i].name || "(unnamed)";
      area.products.splice(i, 1);
      const areaEl = areasContainer.querySelector(`.area[data-area-id="${area.id}"]`);
      if (areaEl) {
        areaEl.querySelectorAll(`tr.product-row[data-product-id="${prodId}"], tr.breakdown`).forEach(r => r.remove());
      }
      log(`Removed product "${nm}" from "${area.name}"`);
      pushStateForUndo(`Removed product from area ${area.name}`);
      updateCalculations(true);
    }

    /* ================== DRAG SORT ================== */
    function enableDragSort(tbody, area) {
      let dragId = null;
      tbody.addEventListener("dragstart", (e) => {
        const row = e.target.closest(".product-row");
        if (!row) return;
        dragId = parseInt(row.getAttribute("data-product-id"));
        row.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        const areaElem = document.querySelector(`.area[data-area-id="${area.id}"]`);
        const canv = areaElem ? areaElem.querySelector(".mini-illustration canvas") : null;
        if (canv) drawAreaIllustration(canv, area);
      });
      tbody.addEventListener("dragend", (e) => {
        const row = e.target.closest(".product-row");
        if (row) row.classList.remove("dragging");
      });
      tbody.addEventListener("dragover", (e) => {
        e.preventDefault();
        const after = getDragAfterElement(tbody, e.clientY);
        const dragging = tbody.querySelector(".product-row.dragging");
        if (!dragging) return;
        if (after == null) tbody.appendChild(dragging);
        else tbody.insertBefore(dragging, after);
      });
      tbody.addEventListener("drop", () => {
        if (dragId == null) return;
        const order = [...tbody.querySelectorAll(".product-row")].map(r => parseInt(r.getAttribute("data-product-id")));
        const newProducts = order.map(id => area.products.find(p => p.id === id));
        if (newProducts.every(Boolean)) {
          pushStateForUndo(`Reorder products in ${area.name}`);
          area.products = newProducts;
          renderAll();
          log(`Reordered products in "${area.name}"`);
        }
        dragId = null;
      });
    }

    function getDragAfterElement(container, y) {
      const els = [...container.querySelectorAll(".product-row:not(.dragging)")];
      return els.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    /* ================== CALCULATIONS ================== */
    function refreshSummaryLabels() {
      const S = state.project.settings;
      const label = S.vatIncluded ?
        (LANG === "sv" ? "Projektets totalsumma (inkl. moms):" : "Project total (incl. VAT):") :
        (LANG === "sv" ? "Projektets totalsumma (exkl. moms):" : "Project total (excl. VAT):");
      footerTotalLabel.textContent = label;
    }

    function updateCalculations(fromSurface = false) {
      const S = state.project.settings;
      let totalCostExVAT = 0;
      const totalsMap = new Map();

      state.project.areas.forEach(area => {
        let areaCost = 0;
        const areaEl = areasContainer.querySelector(`.area[data-area-id="${area.id}"]`);
        const rows = areaEl ? areaEl.querySelectorAll("tbody tr.product-row") : [];

        area.products.forEach((p, idx) => {
          const areaSize = Number(area.size) || 0;
          const layers = Math.max(1, Number(p.layers) || 1);
          const unit = p.packUnit || "kg";
          const price = Number(p.price) || 0;
          const pack = Math.max(0.0001, Number(p.packSize) || 0);
          const priceMode = p.priceMode || "perPack";

          let neededUnits = 0;
          let packages = 0;
          let breakdown = [];

          if (p.calcMode === "usage") {
            const use = Number(p.usagePerM2) || 0;
            let base = areaSize * layers * use;
            breakdown.push(`Base = Area(${areaSize}) √ó Layers(${layers}) √ó Usage(${use}/${unit}¬∑m¬≤) = ${fmt(base)}`);
            base *= area.modifier;
            breakdown.push(`√ó Surface ${area.modifier} ‚áí ${fmt(base)}`);
            if (S.overageIncluded) {
              base *= (1 + S.overagePercent / 100);
              breakdown.push(`+ Overage ${S.overagePercent}% ‚áí ${fmt(base)}`);
            }
            neededUnits = base;
            packages = S.exactMode ? (neededUnits / pack) : Math.ceil(neededUnits / pack);

          } else if (p.calcMode === "thickness") {
            const th = Number(p.thickness) || 0;
            let volL = areaSize * th * layers;
            breakdown.push(`Volume L = Area(${areaSize}) √ó Thickness(${th}) √ó Layers(${layers}) = ${fmt(volL)} L`);
            volL *= area.modifier;
            breakdown.push(`√ó Surface ${area.modifier} ‚áí ${fmt(volL)} L`);
            if (S.overageIncluded) {
              volL *= (1 + S.overagePercent / 100);
              breakdown.push(`+ Overage ${S.overagePercent}% ‚áí ${fmt(volL)} L`);
            }
            if (unit === "kg") {
              const dens = Number(p.density) || 0;
              if (dens > 0) {
                neededUnits = volL * dens;
                breakdown.push(`Needed kg = ${fmt(volL)} √ó ${dens} = ${fmt(neededUnits)} kg`);
              } else {
                neededUnits = 0;
                breakdown.push(`Density missing ‚áí 0 kg`);
              }
            } else {
              neededUnits = volL;
              breakdown.push(`Needed L = ${fmt(neededUnits)} L`);
            }
            packages = S.exactMode ? (neededUnits / pack) : Math.ceil(neededUnits / pack);

          } else { // coverage
            const cov = Number(p.coverSqmPerPack) || 0;
            const covLayers = Math.max(1, Number(p.coverLayersPerPack) || 1);
            const packsNeeded = cov > 0 ? (areaSize * (layers / covLayers) / cov) : 0;
            packages = S.exactMode ? packsNeeded : Math.ceil(packsNeeded);
            neededUnits = packages * pack;
            breakdown.push(`Packs = Area(${areaSize}) √ó (Layers ${layers}/${covLayers}) √∑ ${cov} = ${fmt(packsNeeded)} ${S.exactMode?"(exact)":""}`);
            breakdown.push(`Units = Packs √ó PackSize = ${fmt(packages)} √ó ${pack} = ${fmt(neededUnits)} ${unit}`);
          }

          const cost = (priceMode === 'perKg') ? (neededUnits * price) : (packages * price);
          areaCost += cost;

          const prodRow = rows[idx];
          if (prodRow) {
            const needSpan = prodRow.querySelector(".neededQty");
            const pkgSpan = prodRow.querySelector(".packageCount");
            const costSpan = prodRow.querySelector(".cost");
            if (needSpan) needSpan.textContent = neededUnits ? `${fmt(neededUnits)} ${unit}` : "0";
            if (pkgSpan) pkgSpan.textContent = S.exactMode ? fmt(packages) : String(packages || 0);
            if (costSpan) costSpan.textContent = state.project.settings.hideDecimals ? cost.toFixed(0) : cost.toFixed(2);

            const brRow = prodRow.nextElementSibling;
            if (brRow && brRow.querySelector(".breakdown")) {
              const box = brRow.querySelector(".breakdown");
              box.innerHTML = `
                <div><strong>${p.name||"Product"} ‚Äî ${p.calcMode} ‚Äî ${(p.priceMode==='perKg')?t("priceKg"):t("pricePack")}</strong></div>
                <div>${breakdown.join("<br/>")}</div>
                <div><strong>Cost</strong> = ${(p.priceMode==='perKg')?'Needed √ó Price/kg':'Packages √ó Price/pack'} = ${(p.priceMode==='perKg')?fmt(neededUnits): (S.exactMode?fmt(packages):packages)} √ó ${price} = <strong>${state.project.settings.hideDecimals?cost.toFixed(0):cost.toFixed(2)}</strong></div>
              `;
              brRow.style.display = S.stepMode ? "" : "none";
            }
          }

          const key = (p.name || "(unnamed)") + "|" + unit;
          const rec = totalsMap.get(key) || { name: (p.name || "(unnamed)"), unit, needed: 0, pack: pack, price: price, priceMode: priceMode, exactPackages: 0 };
          rec.needed += neededUnits;
          rec.exactPackages += (neededUnits / pack);
          totalsMap.set(key, rec);
        });

        totalCostExVAT += areaCost;
        const canv = areasContainer.querySelector(`.area[data-area-id="${area.id}"] .mini-illustration canvas`);
        if (canv) drawAreaIllustration(canv, area);
      });

      const label = state.project.settings.vatIncluded ?
        (LANG === "sv" ? "Projektets totalsumma (inkl. moms):" : "Project total (incl. VAT):") :
        (LANG === "sv" ? "Projektets totalsumma (exkl. moms):" : "Project total (excl. VAT):");
      footerTotalLabel.textContent = label;
      const totalDisplay = state.project.settings.vatIncluded ? totalCostExVAT * (1 + state.project.settings.vatRate / 100) : totalCostExVAT;
      footerTotalValue.textContent = state.project.settings.hideDecimals ? totalDisplay.toFixed(0) : totalDisplay.toFixed(2);

      renderTotalsInfo(totalsMap, state.project.settings);

      if (fromSurface) {
        lastInfoTime.textContent = t("updated") + new Date().toLocaleTimeString();
        showInfoToast();
      }
    }

    function renderTotalsInfo(totalsMap, S) {
      const arr = [...totalsMap.values()];
      const info = document.getElementById("infoBody");
      if (!arr.length) {
        info.innerHTML = `
        <div class="info-card" id="moistureCard">
          <strong>Fukt & fuktighet</strong>
          <p style="margin:.4em 0 .2em 0; color:var(--muted)">
            H√∂g fukthalt i underlag/luft kan √∂ka √•tg√•ngen och f√∂rl√§nga torktider. Torka och dammsug ytan noga. F√∂lj databladens klimatkrav.
            <em>(Informativt ‚Äî p√•verkar inte ber√§kning automatiskt.)</em>
          </p>
        </div>
        <em>${t("infoEmpty")}</em>`;
        return;
      }
      const parts = [
        `<div class="info-card" id="moistureCard">
          <strong>Fukt & fuktighet</strong>
          <p style="margin:.4em 0 .2em 0; color:var(--muted)">
            H√∂g fukthalt i underlag/luft kan √∂ka √•tg√•ngen och f√∂rl√§nga torktider. Torka och dammsug ytan noga. F√∂lj databladens klimatkrav.
            <em>(Informativt ‚Äî p√•verkar inte ber√§kning automatiskt.)</em>
          </p>
        </div>`
      ];
      arr.forEach(rec => {
        const exactPk = rec.exactPackages;
        const roundedPk = Math.ceil(exactPk);
        const recommendedPk = roundedPk + 1;
        const exactCost = (rec.priceMode === 'perKg') ? (rec.needed * rec.price) : (exactPk * rec.price);
        const roundedCost = (rec.priceMode === 'perKg') ? (rec.needed * rec.price) : (roundedPk * rec.price);
        const recommendedCost = (rec.priceMode === 'perKg') ? (rec.needed * rec.price) : (recommendedPk * rec.price);

        const exactCostDisplay = state.project.settings.hideDecimals ? exactCost.toFixed(0) : exactCost.toFixed(2);
        const roundedCostDisplay = state.project.settings.hideDecimals ? roundedCost.to
